#git学习经验


>这是我在学习git过程中的一些记录，留待以后参考
>同时也可以作为我的一个git命令的参考手册
>
>--stan


***

<font color="red">参考书使用pro git</font>

**git基本操作**

在命令行中使用`cd d:\gittest\\gitfile`这样的命令首先进入一个文件夹，在这里创建一个仓库

* 使用`git init`初始化这个文件夹，此时git将会创建一个名为`.git`之类的隐藏文件

首先做一点说明，前面初始化的文件夹，称之为`工作区`,在`.git`文件夹中隐藏着git管理的文件，不要去动这些文件，相应的，我们可以将这里也分为两个区，分别称之`暂存区`和`版本库`，我们使用复制等手段，将文件放入文件夹中，即完成了文件进入`工作区`的过程，然后使用`git add abd.txt`诸如此类的命令就能完成文件进入暂存区，然后再使用`git commit -m"***"`即可完成文件进入版本库

* 文件进入暂存区：
	
		git add abc.txt

* 文件提交进入版本库 ：

		git commmit -m"*****"

	其中的***代表此次提交的备注，最好写一些

***

**远程库**


使用远程库，相当于在云端存储了一个本地版本库的备份，当然可以搭建自己的服务器，一个可以使用的免费的远程版本库即为github

至于注册，创建仓库就不说了，我要做的最基本的操作就是将本地的一个版本库和github上面的仓库连接起来，并完成推送等

* 建立本机与github的通信通道，这里只说明`ssh key`，首先，如果本机git的主目录下没有一个名为`.ssh`的目录的话，就首先使用以下命令：

		ssh-keygen -t rsa -C"email@email.com"
	
	这个命令将会产生上面所说的`.ssh`目录，注意，这个目录有可能是一个隐藏目录
	>前面命令中的`email@email.com`指注册github的邮箱地址
	
	找到这个目录，找到里面的`id_rsa.pub`，拷贝里面的所有内容，在github上面有一个add ssh key ,把你拷贝的内容添加到里面去，就完成了本地git与github的关联

* 关联本地版本库和远程仓库：
	
	一般而言，倾向于在github建立一个空白的仓库，不要包含任何文件，包括README，然后本地的文件夹空白与否均可，然后使用下面的命令 ：
		
		git remote add origin git@github.com:帐户名/仓库名.git
	即可建立联系

* 推送 ：

	首次向已经建立好的仓库进行推送使用 ：
		
		git push -u origin master
	做一点解释，经过前面的建立连接的过程，现在对应的远程仓库的代号就变成了`origin`，并没有很特别的意义，其实也可以更改为其他代号，但是并没有太多的必要。
	
	接下来的推送可以简化为：

		git push origin master
	事实上，这些都是默认推送到了远程仓库的master上面，换句话说，现在并不存在分支。

***

**首次小结**

最基本版的操作基本上可以认为到这里就结束了，掌握了如何在本地建立版本库，提交文件，如何与远程版本库建立联系，如何推送，到此为止就拥有了一个网盘，我们已经可以在远程保存本地重要文件的一个副本了。

在接下来的部分，我将说一点其他的，例如分支管理等，接下来基本上是想到哪说到哪，不再按照顺序进行


***

**基础版的分支管理**


所谓分支，怎么理解呢？这么说吧，考虑一个比较大的任务，包含了很多功能模块，有很多人合作，或者一个人完成，一种可行的工作模式是：我们只有一条主干，称之`master`，每个人都把自己写的任意一个版本提交到`master`上面去，不停的修改，提交，这样是完全可以的，但是明显这样条理，层次都很不清晰，另一种可行的方案是：建立很多分支，主干依旧称之`master`，然后每个人都拥有一条自己的分支，每个人在自己的分支上面进行工作，当版本稳定了之后，合并到`master`上面去，这样就象是写代码的时候，会把一个大的代码分解为不同的小功能，每一个都单独写成一份文件，思想是一样的。

* 建立分支


	之前，我们一直使用只有·`master`的情况，现在我们来看一下，如何引入分支。

	比如，现在我们已经拥有了一个`master`分支，在它的工作区和版本库中存在着`a.txt`,`b.txt`两份文件，那么此时使用：

		git checkout -b dev

	就可以快速建立一个名为dev的分支，因为他出现的时候，主干已经有了两份文件，所以此时的dev分支将完全是主干的一个拷贝，它的工作区，版本库中也将拥有相同的文件，然后在dev的分支下面可以进行与之前在master分支下完全相同的操作，例如我们提交了一个新的`c.txt`文件，然后，我们可以进行分支的合并

* 分支合并

	分支合并时，我们是要进行分支的切换的，例如现在我们想把dev分支合并到master上面去，那么首先我们要使用分支切换，切换回master分支，然后进行合并。分支切换的命令如下：
   
		git checkout master

	这样我们就切换回了master，然后执行下面的命令进行合并：

		git merge dev -m"这里是备注"

	注意虽然教程上面大概是没有要写备注的，但是经过我的测试，如果不写会出现一个奇怪的页面，无法进行进一步的操作，根据看到的资料，那个页面似乎是一个应该出现在编辑器上面的反馈信息，其实在使用之前，我们应该首先使用一个命令制定一个编辑器，但是由于我没设置，所以就会出现，总之，我不想，也不太清楚编辑器的设置方法和意义，所以，如果不想出问题，就加上备注

	另外，要说明的是，前面的合并似乎是一种默认模式的合并，称之`fast forward`模式，通过其他命令可以使用非ff模式，但是我不太明白他们的差距何在，所以，在我弄清楚之前，不做记录先。

	如果合并完毕，我们将会看到master分支里面新增了一个文件，即`c.txt`。

	再另外，事实上，当你进行分支的切换时，你打开工作目录的文件夹，你会发现，文件夹里面的内容是在变的，因为他显示的是当前分支的工作区，所以说这很合理。

	然后，如果，我们不再需要这个分支了，如何进行删除呢？

		git branch -d dev

	这样dev分支将会被删除。

	另外说一下，分支合并的条件，要求合并前，两个分支不能同时对同一份文件做了不同的修改，虽然有些资料上说，只要不是对同一份文件的同一部分做了不同的修改即可，但我还是保守一点吧。

	其他情况下，均可无障碍的合并。

* 一种分支的描述

	例如，我首先在master里面存了a,b两份文件，这两份文件都处在不稳定状态里，然后，我可以建立两个分支，分别负责对a,b的修改，每个分支产生了一个稳定版本时，就向master合并一次。

* 远程分支

	假如现在拥有了一个dev分支，那么使用：

		git push origin dev

	就可以在远程建立起一个dev分支

* 可视化

	是的，在命令行里面也是可以实现分支的可视化的，但是，我还是建议去GUI里面去看。


* 暂时说一下接下来要记录什么吧

	版本树的前进回溯

	本地的一些其他的命理

	远程仓库的克隆

	远程分支克隆

	and so on
	

* 一些额外的东西 ：
	
	如果出现了前面说过的编辑器的界面（我应该说过吧），应该执行的操作为：
	1、首先按ESC
	2、输入`:q!`即可强制退出
		


# 重启版

>我重新写一下，前面的太过于功利化了
>
> 2017/4/24 17:47:28    from stan

<br/>

		

##基本操作

###初次设置
---

使用之前，必须要做设置。

+ 设置用户信息: `git config --global user.name "stan"`
+ 设置邮箱： `git config --global user.email xxxx@xxx.com`
+ 设置文本编辑器： `git config --global core.editor vim`
+ 检查配置信息：`git config --list`



###建立一个仓库
---
想要建立一个新的仓库，首先要`cd`进入这个目录，接下来的工作为：

1. 执行`git init`命令，初始化这个文件夹
2. 增加文件，执行命令`git add xx.py`,添加一个文件
3. 提交文件，执行命令`git commit -m'this is one commit'`,`-m`后面的内容为这次提交的说明  
4. 这一步是非必要性操作，`git status`或者`git status -s`

基本上执行完这些操作就可以完成一份文件的提交，下面写一些说明。

#####说明
+ 一个git仓库大概可以分为三个部分，工作区、暂存区、版本库；其中的工作区就是之前初始化的文件夹，将文件放进这个文件夹，那么这个文件即进入工作区；执行命令2，文件进入暂存区；执行命令3，文件进入版本库。后面的两个区都位于文件夹中隐藏的`.git`文件夹中
+ 如果在执行命令3的时候，忘记写`-m`的话，会弹出一个编辑器，这个编辑器就是前面设置过的默认文本编辑器，怎样使用自己处理
+ 还有一个忽略文件的操作，不属于常规操作，不再赘述


#####更进一步
+ 快捷操作，如果一个文件以前已经被追踪过，那么我们可以使用一个快捷操作`git commit -a -m'xxxxxx'`,这样可以不用add直接提交
+ 移除，我们不想再追踪一个文件，如果只是直接从文件夹内删除，那么以后运行任何命令，git都会报错，想要告诉git不再追踪该文件，需要使用`git rm xxx.txt`，接下来需要使用一次`git commit -m'xxx'`保存修改
+ 改名，在git中改变文件的名字，需要使用`git mv old.txt new.txt`,它会自动完成所有操作
+ 文件夹，如果我们想在git仓库中创建多个文件夹，那么只需要直接新建一个文件夹，例如new,即可，然后唯一不同之处在于以后做此文件夹内文件的操作，例如增加，使用带目录的文件名替代文件名即可，例如`git add new/xxx.txt`

#####略过的操作
+ 没有记录关于`git log`的一系列操作
+ 关于所有的撤销操作都没有记录



###远程仓库

---

#####建立ssh连接（只在最初的关联中需要）

1. 生成ssh，如果本机git的主目录下没有一个名为`.ssh`的目录的话，就首先使用以下命令：

		ssh-keygen -t rsa -C"email@email.com"
	
		//这个命令将会产生上面所说的`.ssh`目录，注意，这个目录有可能是一个隐藏目录
		//命令中的`email@email.com`指注册github的邮箱地址
	
2. 添加key至github,找到这个目录，找到`.ssh`里面的`id_rsa.pub`，拷贝里面的所有内容，在github上面有一个add ssh key ,把你拷贝的内容添加到里面去，就完成了本地git与github的关联


#####建立版本库的链接
1. 在github创建一个仓库
2. 在git中执行命令`git remote add <shortname> <url>`，例如`git remote add learn https://github.com/stan12138/learn.git`，这样就把远程仓库关联到了本地仓库，并在本地使用learn这个缩写代表远程仓库
3. 在后续执行`push`之类的操作时，会要求你输入一次用户名和密码

#####说明
+ 一个远程仓库可以关联多个线下仓库，一个本地仓库也可以关联多个远程仓库

#####远程仓库的相关操作
+ 命令`git fetch [remote-name]`,例如`git fetch learn`可以获取远程库上文件，但是并不会合并到本地的任何分支上面去，而是放在其他地方，想做什么操作，需要手动完成，具体还不了解，反正这个命令肯定不是你想要的。
+ 为远程库在本地的缩写重命名，使用命令`git remote rename oldname newname`
+ 查看远程库，`git remote`
+ 本地推送至远程的master分支，`git push [remote-name] master`
+ 拿到远程库的master修改，并合并到本地，`git pull [remote-name] master`

#####重要的说明
+ 操作具有对称性  
		1. 如果我在远程修改、增添、删除文件，再使用`pull`命令，所有改变都会被同步到本地  
		2. 如果我在本地修改、增添、删除文件，再使用`push`命令，改变可以会被同步到远程。
		3. 总结一下，所有的操作都是双向的，但是明显，远程删除，然后`pull`会省一步，较方便


#####克隆操作
如果想要克隆一个远程库，需要依次执行以下步骤：

+ 首先cd进入想要创建库的目录
+ 然后使用`git clone <url>`命令
+ 然后就会自动创建一个与远程库相同名字的文件夹，是远程库的一个克隆，并且已经自动连接到了远程库，在本地的名字叫`origin`,当然，可以使用`rename`改名

#####删除远程库
删除本地仓库与远程仓库的链接，`git remote rm [remote shortname]`

###标签
---
现在，我并没有看出来有什么用

+ `git tag -a v1.0 -m'my tag'` 创建一个附注标签
+ `git tag v1.1`创建一个轻量标签
+ `git show [tagname]`显示一个标签
+ `git tag -a [tagname] [hash] -m'xxxx'`,其中的hash是某一次提交的哈希值的前几个字母，不少于4个
+ `git push [remote name] [tag name]`向远程仓库提交一个标签，`git push [remote name] --tags`提交所有标签

我并没有感觉到有什么用，所以不多赘述

###别名
---
我们可以为git命令定一个别名，例如 ：
 	
	git config --global alias.cm commit
这样，我们以后就可以使用`git cm`代替`git commit`

##git分支


###建立分支、切换、删除、合并（本地分支）

+ 建立，命令`git branch [branch name]`
+ 切换，命令`git checkout [branch name]`
+ 快捷操作，建立并切换，命令`git checkout -b [branch name]`
+ 删除分支，命令`git branch -d [branch name]`
+ 查看分支，命令`git branch`
+ 合并分支，命令`git merge [branch name] -m'xxxx'`


#####说明

+ 如果要删除的分支尚未被合并，那么，使用上述删除命令无法删除，需要改用`git branch -D [branch name]`,另外在该分支上面时，无法删除，必须首先切换出去。
+ `git branch`命令的更多详尽操作未做记录
+ 合并操作的结果，会把branchname分支合并到当前分支
+ 如果发生合并冲突，会要求解决冲突，并阻塞在合并操作中，要放弃合并，需调用命令`git merge --abort`



###关于分支合并操作产生的结果的理解与解释（本地分支）

#####我想说些什么

+ 一种工作流程我称之为单线操作，例如master停止不动，创建分支one,one继续前进，然后进行合并操作，结果大概十分容易理解，相当于只是把master指针前进到one指针处，换句话说，one的所有增、删、修改操作都会被直接反映到master上面去
+ 另一种工作流程我称之为多线操作，例如master停止不动，同时创建两个分支one,two，然后这两个分支各自进行了增删修改操作，那么合并时会发生什么情况呢？
+ 例如，我在分支one上面执行命令`git merge two -m'xxx'`,那么，分支one会发生什么变化呢？关键词只有一个<b><strong>`三方合并`</strong></b>
+ 该如何理解所谓<b><strong>`三方合并`</strong></b>，如果对两个分支进行合并操作，那么git会取出两者最后的版本，再找出两者最后的共同祖先，然后git相当于会记录一下从祖先到two做的所有操作，然后把这些操作全部添加到one上面去

> 呃，这里大概是完蛋了

#####实验记录

+ 在多线操作下，如果操作是文件级别的，也就是说只是删除或者添加了文件，而没有对某一个文件内部做了修改，那么操作的结果就是上面我所说的三方合并的解释

+ 实验一下多线操作下，对于同一个文件内部的修改，会产生什么结果
+ 结论是，多线操作对于不同分支上对于同一个文件修改，然后再合并基本上都会引起合并错误（虽然理论上说，只有对同一部分做了不同修改才会报错）

#####总结
+ 单线操作下，合并操作至今就是指针的移动
+ 多线操作下，不同分支对不同文件进行操作，然后的合并操作等于<b><strong>`三方合并`</strong></b>
+ 多线操作下，不同分支修改同一文件，再合并，会引起合并错误

###变基操作

#####什么是变基操作
所谓变基操作，它所执行的操作正是我之前对与三方合并的工作流程所做的解释：

+ 首先找出两个分支最近的共同祖先
+ 然后记录从祖先到要变基的分支所做的操作的序列
+ 然后对要转到的分支按照这个序列进行操作

#####说明

+ 与分支合并相同，不要考虑使用变基试图合并对同一个文件的修改，也是无法实现的，同样冲突，阻塞，要放弃操作，同样使用命令`git rebase --abort`

#####特性

+ 相对与分支合并，变基操作更加整洁，基本上变基之后直接整个图就变成单线流程了，但是分支合并却要删除分支
+ 更加强大，有趣，下面是一个例子

#####例子
具体的操作需要结合图来解释，然而搞到图片有点难，所以。。。。

	git rebase --onto master server client

这一条命令的意思是，取出client分支，找出其上处于client分支和server分支的共同祖先之后的修改，然后再master分支上重演这些操作  
名字很复杂，效果很酷炫

#####风险！！！
只有一条准则：<font color='red'><u><b>不要对在你的仓库外有副本的分支执行变基操作</b></u></font>

<br/>
<br/>

<br/>

###远程分支与远程仓库的详解
---

#####说明
在这里重新说明一下远程仓库的使用（其中的一些操作可能只是对于github有效）  
<font color='blue'><i>关于建立连接的部分前面的陈述都是可用的，下面的重新说明主要涵盖推送和拉取</i></font>



#####推送
命令的形式主要有以下两种：

	完整版 git push [remote] [local branch]:[remote branch]
	精简版 git push [remote] [branch]
+ 其中的完整版，意义很明显，可以把本地的任意分支推送到远端的任意分支，在github上，如果远端的目标分支不存在，那么会在github页面产生一个创建请求   
+ 精简版，则意味着把本地的branch分支推送到远端的branch分支

#####拉取
拉取的命令也有两个 ：

	git fetch [remote]
	git pull [remote]




#####编码
git bash中无法使用git status显示出中文，使用如下命令修改即可：  

	git config --global core.quotepath false

中文文件有的时候会很烦人，万不得已，必须使用中文的情况下，有可能会遇到想忽略某些文件，但总是有一些即便写在.gitignore中依然会报错，此时可以尝试使用如下命令：

	git status --porcelain | grep '^??' | cut -c4- >> .gitignore
它可以自动添加为被追踪的文件进入忽略文件名单中

<font color='red'><b>fuck windows!!</b></font>我终于知道为什么总是有几个文件莫名其妙报未被追踪的错误了，因为这几个文件还在被word打开着，所以目录下windows自动生成了几个缓存文件，直至你关闭，未被追踪的正是这几个缓存文件。