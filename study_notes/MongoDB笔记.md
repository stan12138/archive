## MongoDB笔记

我安装了mongodb

###环境配置

官网下载community的Windows Server 2008 R2 64-bit and later, with SSL support x64即可，安装，选择custom可以定制文件夹，很快就可以安装结束

之后的过程说实话我也很模糊

我做了很多尝试，但多以失败告终，所以我也不敢确定哪些是有用的

大概应该是这样的:

1.  我们需要一个目录作为db数据的目录，可惜这个目录并不会自动创建，我们可以自己建一个data/db
2.  cd进入mongodb的目录下的bin文件夹，然后执行`mongod --dbpath d:\data\db`，此时你应该可以看到db下出现了很多文件，并且命令行也输出了很多信息
3.  加入环境变量，方便使用。在系统环境变量里新建一个，名字自定，如:`MONGODB_HOME`，值是mongodb的目录一直到bin的上一层，例如`D:\ProgramFile\MongoDB\Server\3.4`，然后编辑系统的path，在后面添加`%MONGODB_HOME%\bin;`，注意path的每一个值都是用；分割的，最后一个也要使用;所以万一前面一个少了;你要记得自己加上，你应该能看出来吧，MONGODB_HOME就是被当作了一个变量，然后使用%标识等等
4.  加入windows服务，这一步我执行了，但是我在服务中并没有找到mongodb，但是至少我的确成功设置了日志文件。我们应该在data下再新建一个dbConf的文件夹，并在里面新建一个空白文件，叫mongodb.log。接下来在管理员命令行输入：`mongod.exe --bind_ip 127.0.0.1 --logpath "D:\ProgramFile\data\dbConf\mongodb.log" --logappend --dbpath "D:\ProgramFile\data\db" --port 27017 --directoryperdb --serviceName MongoDB -install`注意改一下该改的目录。他们说接下来输入services.msc就可以看到弹出来的服务中就有mongodb但是，我并未发现
5.  我们该如何启动mongodb，打开管理员命令行，输入`net start MongoDB`，自己看一下，信息正常就说明应该是开启成功了。
6.  我们打开一个新的命令行，注意只能在bin文件夹打开才行，输入`mongo`，应该就会连接成功，这时我们就可以在这里操作了,例如输入2+2，会给出4，例如db，一般输出test
7.  想要关闭db，网上给了很多方法，但有些看不懂，有些不成功。我成功的就是在上面的操作界面输入`use admin`切换到管理员，然后输入`db.shutdownServer();`即可，这时使用`ctrl-c`可以退出操作界面，然后再mongo，应该会发现连接失败，说明已经退出成功了。先要开启，还要在管理员命令行界面输入net start MongoDB
8.  怎么证明你的确是设置成功了dbpath呢？去之前设置的目录，打开日志文件，应该就能找到。




### 入门

#### 文档

在这里，最基本的数据单元的名字叫文档，文档也是mongodb里面的核心概念，这里的文档其实类似于python里面的字典

不同之处在于这里的键值对是有次序的，这一点又颇类似于数组

键应该是字符串，但是不能包含空字符，而`.`和`$`又有特殊意义，下划线开头的也是保留的

键必须不能重复

#### 集合

集合是一组文档

集合的名字也是字符串，不能为空，不能包含空字符，不能以`system.`开头，不能包含`$`

使用`.`索引集合的子集

#### 数据库

多个集合组成数据库

数据库的命名也是字符串，不能为空，不能包含空格，`.`，`$`,`/`,`\`,`\0`，并且规范上应该是全小写，最多64字节

有一些保留的数据库名字`admin`，`local`,`config`

索引数据库内的集合也是`.`

#### shell

我们使用mongo命令打开的就是shell，他是一个完备的js解释器，所以我们可以在其中使用所有js的功能

##### 入门操作

-   use dbname，切换数据库，若不存在就创建
-   db，查看当前数据库
-   show dbs，查看所有数据库，如果新创建的数据库啥也没有，就不会显示
-   show collections，查看当前数据库的所有集合

##### shell的基本操作

四个基本操作：创建，读取，更新，删除

###### 创建

我们需要首先在shell里面创建一个文档，例如：

~~~python
post = {"title":"this is stan",
       "content":"stan's first test",
       "date" : new Date()}
~~~

接下来使用插入命令，将文档插入到当前数据库的指定集合中：

`db.blog.insert(post)`

这样就将post插入到了当前数据库的blog集合里面去了，这个集合就是在调用这个命令的时候创建的

###### 读取

`db.blog.find()`和`db.blog.findOne()`可以查看文档，前者最多显示20个，后者就是一个

###### 更新

使用文档的点号索引可以索引里面的键，并且赋值操作可以创建或更改

更新操作实际上是一个查找，然后替换的过程，我们首先需要创建一个新版本的文档，然后调用`db.blog.update({"title":"this is stan"},post)`这条命令的意思是：在blog里面查到title为this is stan的文档，然后用post替换他

###### 删除

删除操作也是一个先匹配的过程：

`db.blog.remove({"title":"this is stan"})`

将删除title为指定值的文档

##### 注意事项

一般我们可以使用点号去访问集合，但是如果集合的名字恰好和属性名，或者函数名一致就麻烦了。这个时候应该使用`db.getCollection(name)`去访问集合

包括特殊字符也要使用这种方式访问

因为是js所以点号索引和方括号索引是一致的



### 数据类型

#### 基本数据类型

-   null
-   布尔，true/false
-   32位int，支持这个类型，但是因为shell是js，所以在shell里面不可用
-   64位int，shell也不支持
-   64位浮点，在shell里面数字就是这种类型
-   字符串
-   符号,shell不支持
-   对象id
-   日期，new Date()
-   正则表达式，可以包含正则表达式，采用js的语法
-   代码，可以包含js代码
-   二进制,shell不支持
-   最大最小值
-   未定义,undefined
-   数组
-   内嵌文档，值可以是另外一个文档

#### 数字

因为shell只有64位浮点数，所以，如果你在shell下读取保存数据库，那么数据库内的数字将会被改变

#### 日期

就是使用new Date()，但是因为js的原因，这里得到的是一个字符串，而不是Date()对象

#### 数组

mongodb可以深入到数组内部

#### 内嵌文档

同样可以深入文档内

#### _id和ObjectId

所有文档都有一个_id的键，值可以是任何类型，默认是ObjectId对象，如果你不创建的话，系统会自动创建。集合内每个文档id唯一

##### ObjectId

它使用12字节空间，十六进制，因此是24位字符串

12字节包含了时间戳，机器主机名散列值，进程标识符，计数器



### 文档的操作

#### 插入

基本的就不说了，这里增加一个批量插入：

批量插入传入一个有文档组成的数组即可

一次消息长度是16MB，所以批量也有限制，一个文档的最大大小为4MB

#### 删除文档

还是前面所说的db.blog.remove()方法，如果不给参数的话，会删除所有文档，可以提供一个查询匹配参数

删除不可撤销，不可恢复

通常而言，删除是很快的，但是如果要删除整个集合的话，还是drop_collection(name)快的多得多

#### 更新文档

更新文档使用的还是前面说的`db.blog.update()`，这个方法接收两个参数，第一个参数是一个匹配器，第二个是一个修改器，匹配器使用某个键指出我们想要修改哪个文档，修改器指出对文档做什么样的修改。

##### 文档替换

这里有一点技巧，例如我们想要替换一个文档，并且只是修改一部分内容，那么，我们没必要从头创建一个新的，我们可以直接获取这个文档的副本，然后做一些修改即可，获取的时候就是使用查找，我们可以向find或者findOne里面传入一个查找器，这里要注意无论有几个结果find的结果总是一个数组什么的，只有findOne返回的才是一个文档。

例如：

~~~
var stan = db.blog.findOne({"title":"stan"});
stan.title = "nats";
db.blog.update({"title":"stan"},stan);

~~~

这里一定要注意唯一性

##### 修改器

修改器可以只修改文档的某一部分，增删等操作，每个修改器都有一个特殊的名字，然后使用的时候要依靠一个可能看起来会比较奇怪的语法

###### $set修改器

`$set`修改器可以指定一个键的值，如果不存在，则会创建。用法：

`db.blog.update({"title":"stan"},{"$set":{"title":"hanyi"}})`

此外，我们还可以直接删除一个键：

`db.blog.update({"title":"stan"},{"$unset":{"date":1}})`

###### 增加与减少

针对值是数值的键，我们可以使用`$inc`修改器来在原基础上增加或减少一定的数值

`db.blog.update({"title":"stan"},{"$inc":{"a":2}});`

如果原本没有这个键，就会创建，然后把数值指定为增加量

###### 数组修改器

键的值必须是数组

`$push`可以在尾部增加一个元素，如果没有就创建一个。

`db.blog.update({"t":"s"},{"$push":{"ar":10}});`

还可以实现`$ne`完成如果数组不存在该元素则添加，但是`$ne`是用在选择器里面的，而不是修改器

`db.blog.update({"ar":{"$ne":10}},{"$push":{"ar":10}});`

但是，`$ne`有些时候是无法使用的，这个时候其实最好的是使用`$addToSet`

`db.blog.update({"t":"s"},{"$addToSet":{"ar":10}});`

他直接就可以实现避免重复添加

还有一些更高级的操作，我们可以使用`$addToSet`配合`$each`实现批量添加，只需要把批量添加的内容放入一个数组即可：

` db.blog.update({"t":"s"},{"$addToSet":{"ar":{"$each":[12,13,14]}}});`

数组的删除操作要使用`$pop`或`$pull`，前者删掉数组头部或尾部的元素，后者可以删掉匹配条件的数组的元素

`db.blog.update({"t":"s"},{"$pop":{"ar":3}});`

如果数值是正数就删掉最后一个，负数删第一个，至于绝对值是多少完全没影响

pull的话，例如数组是[1,1,2,3,1]，然后pull 1的话，剩下的就是[2,3]



###### 数组定位修改器

这个就很厉害了。

还记得前面的一些操作吗？例如inc，`db.blog.update({"title":"stan"},{"$inc":{"a":2}});`

其实这里的a如果是一个数组的话，我们还可以这样写：

`db.blog.update({"title":"stan"},{"$inc":{"a.0":2}});`

也就是说我们可以在参数里面就使用`.`索引，数组的话可以直接在点后面加下标，文档的话可以直接加键

这个点号索引还可以用到选择器上，例如：

`db.blog.update({"title.0":"stan"},{"$inc":{"a":2}});`这里表示title是一个数组，我们要找到title的第一个值是"stan"的文档

然后呢，还提供了`$`来定位已匹配元素，我认为这个只对比较复杂的又需要，针对那些我们想要修改特定元素，而又不知道这个元素在数组里的下标，举个栗子：

文档的comments键是一个数组，数组的每一个元素都是一个文档，每个文档都有一个title键，现在我们想修改title等于stan的那个数组元素的title

`db.blog.update({"comments.title:stan"},{"$set":{"comments.$.title":"asimo"}})`

这里很诡异的地方在于前面的选择器似乎实现了跨级索引，comments的元素是文档，文档才有title键，但是他直接就使用了comments.title

注意只会更新第一个，而不是所有

##### upsert

哇，单单是更新的修改器部分就有这么多，这一部分还是更新

upsert是特殊的更新，使用它的时候，只需要给update传入第三个参数即可，第三个参数设置为true。

它的行为是，首先根据查找器查找集合，如果发现了文档，就执行修改器，如果没有，就创建一个文档，这个文档存在着查找器所指定的东西，然后再对这个文档执行修改器

想要更快的吗？是不是感觉有点麻烦，那么接下来向你介绍已更厉害的函数：save

`db.blog.save(x)`

x是一个文档，我们可以首先使用findOne拿到一个文档，然后修改，然后save，这样的话只要你不修改id，就会更新过去

如果改了id就会添加。

所以他和直接update文档的区别就在于，不用写选择器了

##### 更新多个文档

想要更新多个文档的话，就把第四个参数设置为true，所以这是必须设置第三个参数，例如false，建议这第三四个参数最好显式表示一下

##### 返回已更新文档

findAndModify，这个对于多线程竞争很有效？我也不知道，跳过



#### 查询

呃，不想写了。先到这吧。