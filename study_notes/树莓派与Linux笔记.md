## 树莓派与Linux笔记

拿到树莓派四天了，我重装了三次系统，我想我有必要记录一下配置过程了。



### 材料

我使用的是树莓派3B，英国版，欧时电子生产，事实上欧时电子和易络盟生产的产品没有不同，英国版与中国版的区别也就是代工厂的所在地不同，甚至有很多人反映中国版的加工精细度要优于英国版，英国版的PCB的确有一些讨厌的毛边，除此之外完全没有区别。

除此之外，至少需要外壳，2.5A电源，最好是32G SD卡，class 10，读写速度越快越好，虽然网上有很多教程是关于完全无键盘鼠标，显示器的配置方法，但是我还是觉得有这些会方便很多很多。

所以，额外还需要键盘，鼠标，显示器，HDMI线。

散热片也是要贴的，这个很简单，就不描述了，注意别贴错就好。一般而言要贴三个芯片

当然还需要有线网，我的策略是首先使用有线网完成配置，之后切换到无线网。

我们首先需要准备系统，直接搜索树莓派即可，下载raspbian系统，img格式的，下载会得到一个压缩文件，解压即可，一般而言，解压得到的文件大概是4G多，下载的文件1.6G左右。

然后还需要，SD Card Formatter这个软件，自己搜索吧，第一次尝试烧录系统的时候我并未格式化，但是系统启动失败了，并不能确定一定是未格式化的问题，但是很有可能，建议还是先格式化。格式化的时候直接默认即可，默认应该就是快速格式化，只要注意一下盘符不要选错了。

然后需要Win32DiskImager这个软件来烧录系统，选择img文件所在位置，选择要烧录的盘符，然后write即可。

一切完成之后，插入SD卡即可。插入键盘鼠标，网线，电源，HDMI，然后开机。

### 系统配置

一般而言，我会首先选择做磁盘扩展和分辨率的更改。

打开Lx终端，输入`sudo raspi-config`，回车打开，使用方向键选择，首先选择第一项，扩展磁盘至整个空间，然后选择高级选项->分辨率，选择1920x1080 60Hz，使用左右方向键选择Finish，应该是需要重新启动的。

接下来，需要设置一下软件映像的源，在终端输入`sudo nano /etc/apt/sources.list`，回车，将在nano编辑器打开上述文件，使用方向键移动到源文件正文的末端，删除注释之外的所有内容，然后键入：

~~~
deb http://mirrors.ustc.edu.cn/raspbian/raspbian/ jessie main non-free contrib
deb-src http://mirrors.ustc.edu.cn/raspbian/raspbian/ jessie main non-free contrib
~~~

然后`ctrl+x`退出，会让你选择时候保存为和原文件名字一致的文件，输入y，回车

上述操作将镜像替代为了中科大的开源镜像网站

然后在终端输入`sudo apt-get update`更新一下列表，中途如果有询问，输入y即可

下一步，安装vim，终端输入`sudo apt-get install vim`，如果报错了，一般而言原因是原本有一个`vim-common`，此时需要首先移除，输入命令`sudo apt-get remove vim-common`，同样如果询问，输入y

然后重新执行`sudo apt-get install vim`



下一步，需要开启SSH和VNC，直接在上面的bar上点击，选择首选项，然后选择树莓派配置，在选项卡里面找吧，很好找的，使能上述两项，然后还要选择最后一个选项卡，设置地区，时区，地区可以选择中国，时区选亚洲，香港，编码格式应该默认就是utf-8。保存，应该还是需要重启。



然后需要安装中文输入法和中文字体，在终端依次执行：

`sudo apt-get install ttf-wqy-microhei`和`sudo apt-get install fcitx fcitx-googlepinyin fcitx-module-cloudpinyin fcitx-sunpinyin`

网上也有安装很出名的龙泉驿开源中文字体的`sudo apt-get install ttf-wqy-zenhei`

输入法使用ctrl+space切换，如果没有中文的话，应该是你没选中文，打开fcitx的输入法设置，添加谷歌拼音即可

接下来，要配置wifi，我将使用修改文件手动添加wifi的方式，我认为这样非常便捷，并且可以添加已知的，但不在范围内的wifi，终端输入命令`sudo vim /etc/wpa_supplicant/wpa_supplicant.conf`，然后在文件的尾部加入：

~~~
network={
	ssid="xxxxxx"
	psk="xxxxxx"
	priority=4
}
~~~

其中优先级数字越大，级别越高

关于vim的操作的问题自己解决吧

只提一点，在linux里面，复制粘贴没有那么麻烦，ctrl的方式是不支持的，直接左键选中，那么复制已完成，中键就是粘贴



此时需要在桌面找到网络的图标，打开wifi，将网络切换到wifi模式



几乎是最后一步设置，我们需要解决校园网登陆问题。这里的问题解决策略是：

1.  完成一个python脚本，首先抓包搞清楚校园网登陆的表单格式，然后通过requests模块发送报单，会进行多次尝试，防止一次尝试失败。
2.  在同一个脚本内，获取ip地址，然后发送到邮箱
3.  将这个脚本设置为开机启动，注意为了防止系统尚未启动完成，脚本的一开始要延时一下，例如20秒

因为脚本涉及到了比较多的登录信息，这里不再给出，相信我已经保存了一份可靠的备份

只是说明一下如何将脚本设置为开机启动，按照网上的解决方案，他们认为有三种途径解决，分别是以服务的方式，设置权限的方式和修改`rc.local`的方式

我现在认为最后一个最快捷，也是最靠谱的。终端键入：`sudo vim /etc/rc.local`，打开这个文件，然后在`exit 0 `这一行之前输入你想要执行那个命令，例如`python3 /pi/home/blabla.py`，保存即可



此时最后检查一下VNC，SSH开启，wifi开启，为了方便，最好蓝牙也开启。哦，我们还需要更改一下密码，同样是`sudo raspi-config`，找到修改密码，输入即可，注意linux下，你输入密码是不会回显的，所以不必惊慌

至于root什么的，暂时可以不管。



最后最后，我还没有解决的问题是，键盘，我曾经正确的设置过，但是今天我不知为何无法重现，所以这个问题暂时搁置。



### 客户端

上述设置如果全部正确完成的话，接下来可以拔掉网线，键盘鼠标，HDMI，只保留电源线即可。

客户端主要使用两种，VNC viewer和PuTTY，前者类似于远程桌面，所以应该很清楚吧，远程桌面的话对网速有要求，会略显不流畅，同时往往分辨率也不会让人满意，至于下载就不说了，记住是viewer，别下载成服务器了。

后者这命令行界面，只传输命令行终端，下载，打开选择SSH，端口默认22即可，输入ip，之后还会需要用户名和密码，用户名是pi，默认的

基本上到这里就暂时告一段落了



### Git

树莓派自带git，也许所有linux都自带git





### 警告

现阶段，我并不熟悉系统的操作，所以不要瞎搞

例如nginx和uwsgi，我暂时就用不上，所以别装了，上一次系统出问题就是因为安装这个，它似乎删了我几个软件，然后系统面目全非，亲爹都认不出来了，于是我重装了:cry:





### 说明

基本上绝大多数时间，当我在学习的时候我就是在学习Linux，所以，可能会有相当的部分，我实际上在写Linux的笔记，而且为了更加高端一点，我专注于shell，bash编程什么的，也就是命令行。

我使用的教程是the linux command line中文版，这个的pdf有点难找，主要原因是网上大多数的内容格式有问题，例如表格未正常显示，找了很久才找到一个比较完美的版本。





### 如何配置vim

~~~
set smartindent # 自动缩进，例如当输入一个花括号，然后回车，会自动缩进一个tab
set shiftwidth=4   # 自动缩进的时候缩进长度是4个空格
set nu     # 设置行序号
set ts=4   # tab键等于四个字符
set expandtab  # 将制表符扩展为空格
set autoindent  # 没用吧
set softtabstop=4 # 让vim将连续数量为4的空格视为一个制表符
~~~

在vim的配置文件中`“` 是注释符号

上述配置，并不能让vim识别出python代码，并自动在函数定义的冒号之后回车自动缩进，但是因为它会自动保持缩进，所以，其实也挺好用的。

对于当前用户的vim配置，是可以直接在当前用户的目录下建立一个`.vimrc`文件进行个人配置







## 命令行

### 目录检查，跳转，基本文件查看

`pwd`，当前目录

`ls`，显示当前目录的文件，简短格式，不包含隐藏文件

`ls -l`，长格式，`ls -la`长格式，包含隐藏文件，`ls -lah`长格式所有文件易读格式(易读指的是大小不再是字节，而是友好的k，M等)

`cd`，更改文件夹，绝对目录就不说了，相对目录的话要使用`./abc`，其中的`.`代表当前，`..`代表父目录，当然可以使用`cd abc`省略`./`，规律很明显了，自己看吧

`file filename`查看文件基本信息，主要是格式

`less filename`查看文件信息，当内容很长的时候，可以使用方向键滚动，退出查看是`q`



### 文件与目录操作

#### 通配符

意义很明显吧，通配符的存在。

这里的通配符没有正则表达式那么复杂，相对简单：

`*`匹配`0~n`个任意字符，`?`匹配`1`个任意字符

`[set]`这是字符集，匹配一个

`[!set]`，匹配非字符集内的一个

特别的，上述的set有一些特殊的值，例如`[:alnum:]`任意字母和数字,`[:alpha:]`任意字母,`[:digit:]`任意数字，`[:lower:]`任意小写字母，`[:upper:]`任意大写字母



给出一些例子：

`*`所有文件

`g*`以g开头的所有文件

`b*.txt`以b开头最后四个字符是`.txt`

`[abc]*`以abc其中之一开头的任意文件

`[[:upper:]]*`以大写字母开头的任意文件

`*[![:digit:]abc]`任意不以数字或者abc字母结束的文件



注意此外的任意正则表达式里面的用法都很可能是不支持的，所以别用，例如`[a-z]`这样的写法



### 创建，复制，删除，移动

`mkdir dirname1 dirname2 dirname3...`创建多个目录

`cp name1 name2`

复制可以是文件，也可以是文件夹，总是把前面的复制到最后一个，例如`cp f1 f1 f3 f4`代表把f1f2f3复制到f4

但是f4必须是一个已经存在的文件夹，对于文件内容的复制，只能是两个文件，文件可以不存在，所以说如果是两个参数，那么会根据后一个是否是一个已存在的目录抉择，如果是多个参数，最后一个必须是一个已经存在的文件夹

同时这个命令还支持一些选项，例如`cp -a name1 name2`复制所有内容，包含权限等，`-i`重写已存在文件时提示确认，`-r`递归复制目录下的所有内容，`-u`仅复制与目标文件夹内不同的文件进入，`-v`显示操作信息

操作上还有很多细节要注意，有些地方也许写错了。

`mv f1 f2`，将f1移动或者重命名为f2

`mv f1 f2... d1`，将多个文件移动到目录d1

同样也可以使用`-i`,`-u`,`-v`选项

`rm name1 name2...`删除文件或者文件夹

选项`-i -r -f -v`

对于删除命令没有复原选项，所以要小心



### 使用命令

`type command`测试command这个命令的类别

`which command`找到命令的所在位置

有的时候，我们需要配置已安装的软件的某些文件，但是也许我们并不知道它装在哪了，此时可以使用上述两个命令，例如`which vim`

`help command`显示命令的帮助

`command --help`显示命令的用法信息

`man command`显示程序的手册页

`whatis command`显示非常简洁的命令说明

等等帮助就不说了



`command1;command2;command3...`同时执行多个命令



定义命令的别名，`alias name='commandlist'`，要严格遵守这个格式，例如`alias foo='cd /user;ls;cd -'`，注意定义之前，你应该先使用`type`确定别名不是内建命令



删除别名 `unalias name`删除name这个别名



### 重定向

I/O重定向，据说这个很有意思



我们可以把标准输出重定向到我们指定文件中。

`ls -la > record.txt`要注意这个命令的特性，对于重定向而言，可以认为他不会在乎record.txt是否存在，他会新创建一个，并将此次的内容写入，换句话说是覆盖的

也要注意，这里是重定向标准输出，所以如果命令执行错误，你将得到一个完全空白的文件。

为了追加内容，我们应该替代为`ls -la >> record.txt`



在shell内部，文件流中的前三个：标准输入，标准输出，标准错误分别对应文件描述符0,1,2。而标准错误是没有专门的重定向符的，所以，替代的使用 `ls -l .bin/usr 2< record.txt`这样的描述，`2紧贴<`

需要联合标准输出和标准错误的时候，有旧新两种方法，老式的是`ls -l bin/usr > record.txt 2>&1`

新式的方法更简洁`ls -l /bin/usr &> record.txt`



如果只想废掉输出，不想到屏幕，也不想到文件，那么系统提供了一个类似垃圾箱的文件`/dev/null`，所以可以用`ls /bin/usr 2> /dev/null`

这里要注意，无论是前面说的使用`>>`实现添加，还是将标准输出定义到垃圾箱都是可以在这几个地方通用的，词不达意，但是你知道我在说什么



#### 标准输入

`cat`命令可以连接多个文件，并复制到标准输出，所以我们可以用于拼接文件，例如一个文件下载的时候被分割成了数块，例如`a.jpg.0,a.jpg.1,a.jpg.2`等，可以拼接`cat a.jpg.* > a.jpg`

所以，明显cat会从参数读取内容，到标准输出，或被重定向，但是如果没有参数呢？此时它会等待接收标准输入的内容，如`cat >> record.txt`，此时cat会等待键盘输入，读入直至文件结束符`ctrl-d`

此时。你要注意，如果你输入结束后应该先回个车，然后再`ctrl-d`这样体验会好很多，直接写`\n`是没用的



于是我们可以将标准输入定向到其他地方，那么怎么才能将标准输入源从键盘改到文件呢？ 只需要`cat < record.txt`即可



#### 管道线

命令从标准输入得到内容，输出到标准输出，我们可以截获这种操作，将a的输出变成b的输入，只需使用管道线：`command1 | command2`

为了使用我们需要一个合适的command2，一个选择是less，当前一个命令会产生极长的输出，导致查看十分不便的时候，我们可以使用`ls -l /usr/bin | less`，它可以为前一个命令的输出提供一个less界面的查看方式，会友好方便很多。



#### 过滤器

多个命令通过管道线组合，完成特定的过滤命令。称之过滤器。

例如，有一个命令是sort。它可以对输入排序，于是我们可以这样组合`ls /bin /usr/bin | sort | less`这样可以以友好的方式查看排序过的两个目录的输出

sort常和uniq组合，后者会将输入内容中重复的删除，于是我们可以这样组合`ls /bin /usr/bin | sort | uniq | less`

uniq还可以带一些参数



再加上一个`wc`，它可以统计文件的行数，字数，大小，加上选项`-l`可以只显示行数，于是可以这样统计：

`ls /bin /usr/bin | sort | uniq | wc -l`



再加上一个grep，这个命令匹配文件中的内容

`ls /bin /usr/bin | sort | uniq | grep zip`找到所有包含zip的文本

选项`-i`忽略大小写，`-v`只打印不匹配行



还有两个命令`head/tail`，他们可以只打印开头或结尾的指定行数，默认10行，可以调整`-n 5`打5行

例如`ls /bin | sort | tail -n 5`

还有一个实时浏览选项`-f`，他会持续监视文件，直至你输入`ctrl-c`结束



再来最后一个，很厉害的`tee`，它相当于一个观察者，一个管道的一段，他会拿到输入到它的内容，同时输出到选项提供的文件中，同时但是他不会阻止管道内信息流的流动，进入它的内容仍会原样输出

`ls /usr/bin | tee record.txt | grep zip`

这个会同时记录输出，并完成匹配



### shell眼中的世界

对shell来说，他在解释一个字符的时候会做展开的，并非原样接收，例如已知的`*`就有特殊的含义

所以`echo *`是输出了当前文件夹下的所有顶层文件/文件夹

`ls`命令其实也算是一种展开

那么明显，我们可以借助echo和匹配表达式输出特定的文件或文件夹

`echo D*s`

对于不存在匹配的内容的，可能会原样输出



`~`也有特殊含义，代表了当前用户，或指定用户的家目录



支持算数表达式展开`$((expression))`，其中的算数表达式包含整数和操作符，不支持小数，运算符可以是`+-*/% **`

`echo this is $((5%2)) left`



神奇的花括号展开，这种展开会对花括号内的任意字符执行相同的模式，例如：

`echo a{1,2,3}b`会输出`a1b a2b a3b`

花括号内的内容除了逗号分隔的枚举值，也可以是缩略的如`{a..z}  {1..9}`这样的

`echo {2007,2008}-0{1..9} {2007,2008}-{10,15}`



参数展开，就是引用自定义或内置的变量`$name`



命令替换，`$(command)`，它可以将command的输出作为一个展开模式，例如，搞到一个命令的目录，并输出信息

`ls -l $(which cp)`



展开控制，`echo hello this is   test`，结果是`hello this is test`，`echo this is $100.0`输出`this is 00.0`

以上两个例子说明正常情况下展开总是存在的，他会自己去掉多余空格，因为引用了1这个变量，而他并不存在，所以就消失了

 如果我们想要禁止这些展开该怎么办，方法是引号，引号的作用分为两个级别，双引号弱一点，单引号会禁止所有的展开

双引号将禁止空格，路径名，波浪线，花括号，但是参数展开，算术，命令替换，`$ \ `和反引号依旧保留作用

单引号禁止所有的



这一部分最后介绍的是转义字符，转义字符可以让`$`等一些特殊字符丧失意义，也可以是常见的转义字符





### 高级键盘操作

#### 移动

我真的不太习惯这些移动操作，`ctrl-a ctrl-e`行首与行尾，`alt-f alt-b`前移后移一个字



清空屏幕`ctrl-l或者clear`这个还是比较实用的



#### 修改

这些大概真的不会用了，是一些用于改变大小写，交换位置，删除的



#### 剪切与粘贴

`ctrl-k`剪切光标至行尾的内容

`ctrl-u`行首

`alt-d`光标至词尾

`alt-backspace`光标至词首，若在开头，剪前一个

`ctrl-y`剪切环中的文本至光标



tab补全，只补存在单一可能性的命令



`alt-?`显示所有可能



历史命令，`history | less`会输出记录的历史命令的列表，每一个都带一个编号，我们可以使用这个编号引用某一个历史命令，例如`!10`引用第10个，这种方式称之历史命令展开



### 用户与权限管理

`id`查看自己的身份

文件或目录的所有者或者超级用户，可以更改文件/目录的权限，更改权限有两种方式，已经知道每个文件的权限分为三个组，分别是所有者权限，组用户，其他人的权限，每个都有三位rwx，分别代表读写执行，如果没有相应的权限输出就会看到`-`，假设我们定义一位上面有相应权限是1没有是0，那么三个组可以转换为三个八进制数字，例如600.

在第一种更改方式里，我们使用3位8进制数字，如`chmod 600 record.txt`

另一种更改方式使用字符，比较麻烦，他的优点在于可以单独修改一部分，有四个特殊字符`u g o a`分别代表拥有着，组，其他人，所有。

然后使用两个增删符`+ -`前者代表增加某权限，后者代表删除权限，权限就是`r w x`

例如`o-w`

我不喜欢这种用法



创建文件的时候使用默认权限的`rw-rw-rw-`，我们可以指定一个掩码，删除某种权限，掩码是4位8进制，第一位对应文件类型，因此要设置为0，其余位转换为二进制，是1的位对应的权限会被删除

我们使用掩码修改默认权限,`umask 0000`这样



#### 更改身份

`su`切换，我已经用过了



`chown ownername:groupname filename`同时修改某文件的拥有者和用户组，可以缺两个中的任意一个



设置用户密码：`passwd username`



树莓派应该默认没有root？好像吧，使用`sudo passwd root`为root创建一个密码，然后就可以使用root了



### 进程

`ps`查看进程，只列出了与当前终端有关的进程，`ps x`查看所有进程，建议结合less管道查看，`ps aux`查看携带了用户的进程消息

`ps`提供的只是进程快照，`top`可以查看动态信息，默认三分钟刷新一次，`q`退出



#### 进程控制

这一部分书上建议自行创建一个测试进程，如`xlogo,gedit或kwrite`可惜，树莓派都没自带，那就算了吧。



例如`xlogo`这些进程的执行会阻塞命令行，中断的方法就是熟悉的`ctrl-c`，但是这个并不通用

因此，我们可以将一些会阻塞的进程在后台执行，方法就是在程序命令之后加`&`，此时会输出`[1] 28236`的字样，方括号内是工作号，后面是进程号

`jobs`可以查看当前终端启动的任务



麻烦的在于，放进后台的进程将对所有键盘输入免疫，那么该怎么关掉呢？

我们可以使用`fg %工作号`将指定工作返回到前台

把前台的放进后台`bg %工作号`



#### 杀死进程

`kill -signal PID`可以向指定进程发送指定信号，默认是终止信号，signal的取值是整数，每个代表不同的含义，这里不再明说

`kill -l`可以得到完整信号列表

还有同时向多个进程发信号的`killall`等等就不描述了



### shell环境

shell存储了大量跟运行有关的数据，信息，称之shell环境，另外还有环境变量，它们一般是变量，就是`大写字母的名字=值`这样的形式，在shell环境中额外还有一些函数

明显对于变量，我们可以使用`$name`的形式引用，`echo $PWD`

`set`查看上述两者，`printenv`只看环境变量，两者都很长，所以建议less

我们可以通过修改实现自己定制化的shell，但是我并不需要，跳过。



### 自定义shell提示符

命令行里面的提示符是由环境变量`PS1`定义的，我们可以更改它实现自定义的提示符

也可以使用`echo $PS1`参看当前的提示符，会发现这里面包含了大量具有特殊意义的字符，主要是一些特殊意义的转义字符和颜色

这里定制化的自由性很大，但是，我并不想用，很复杂



### 包管理



### 关于脚本运行

如果想在SSH中运行一个python脚本，并让它保持在后台运行，SSH退出的时候，脚本持续运行。

那么我们需要`nohup python3 test.py &`

当我们想要找到这个在后台运行的进程，并关闭它的时候，首先使用`ps -ef`找到这个进程的PID，然后kill即可