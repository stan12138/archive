## Common Lisp学习笔记

要不来学习一下Common Lisp吧.

参考书: [Practical Common Lisp]( https://book.douban.com/subject/1456903/), 我看到的版本是2011年出版的, 所以应该还算是蛮新的吧.

另外一本参考书是ANSI Common Lisp

### 开发环境部署

如我一直以来认为的, 部署一个开发环境, 是学习一切的先决条件.

书中推荐使用`Lisp in a Box`, 这是一个IDE, 但是按照书中的链接你是无法找到的, 你可以在source code下载里面找到README, 里面有链接, 但是似乎按照页面上的说法, 这个似乎已经不再维护了? 反正11年至今没有再发布过新版本.

如果你用谷歌搜索现在最好的Common Lisp开发环境, 那么结果应该是[Portacle](https://portacle.github.io/), 在Reddit上面也有很多人推荐使用这个, 于是, 你应该去官网下载一个这个.

按照官网的介绍, 似乎这是一个可以装在U盘里面的便携运行环境, 但是实际上点击下载得到的exe, 还是执行了一个安装程序, 然后在安装后的位置可以找到一个`portacle.exe`, 运行即可.

看到的界面应该是和官网上给出的图片完全一致, 你也可以试一下运行官网给出的那个`what's your name`的例子.

所以, 开发环境算是已经搞定了, 虽然这个IDE的长相我完全看不懂, 很奇怪, Emacs,我也几乎没有什么使用经验, 总之就是一团混乱, 文件存在哪? 编译?等等, 我还是一片混沌. 

后面应该会逐渐熟悉的, 但是真的需要看一下Emacs的基本操作. 



### 运行

Lisp提供一个交互式的运行方法, 术语叫做toplevel



### 基础知识

lisp使用前缀表达式, 求和表达式为如下形式:

~~~commonlisp
(+ 2 3 4)
~~~

其中的`+`叫做运算子, 也是一个参数, 特别的可以发现他可以接受多个参数, 并把它们相加, 之所以加上一个括号, 就是需要用括号来指定范围.

~~~commonlisp
(/ (- 7 1) (- 4 2))  ; 3
~~~



`quote`运算子的功能是什么也不做, 接收一个实参, 然后原样返回, 所以:

~~~commonlisp
(quote (+ 3 5))  ;(+ 3 5)
~~~

`quote`等价于`'`



数据类型有整型, 字符串, 字符串使用双引号, 还有符号和列表, 符号在我看来类似于变量名, 需要注意的是符号我们一般选择小写输入, 但是统统会被转为大写.

列表使用`()`, 内部的元素可以有0到n个, 类别不限, 但是因为`()`也用于函数调用就像之前那样, 所以我们只是想单纯表示一个列表, 那么必须使用quote, 例如:

~~~commonlisp
(2 3) ;报错
'(2 3) ;正确
~~~

然后需要注意的是, 假设我们想要在列表里面放入一个符号, 那么需要注意, 符号必须使用quote, 否则就会尝试对符号求值, 然后肯定会报错.

空列表直接使用`()`, 也可以使用`nil`, 他们都等价于`NIL`

list函数可以生成一个列表, 但是也会执行必要的求值, 如果没使用quote的话

~~~commonlisp
(list 'my (- 7 1) "hahah") ;(MY 6 "hahah")
~~~

`cons`函数接收两个参数, 相当于append, append的内容是第一个参数, 原始内容是第二个参数:

~~~commonlisp
(cons 'a '(b c d))
~~~

`car`和`cdr`两个函数分别可以返回一个列表的第一个值和除了第一个值之外的值, 因此混合这两个函数就可以获取我们想要的任意位置的元素



逻辑值, 逻辑值的真值是t, 假是nil

函数listp可以用来判断给的参数是不是列表, 如果一个函数的返回值是真或者假, 这种函数常称为谓词,谓词的结尾通常是p

函数null可以判断给的参数是不是一个空表

函数not可以取反

因为nil可以表示一个空表, 同时也可以表示假, 所以null函数和not功能一样

此处要注意假就是nil, 0并不是假





条件函数if接受三个参数, 分别代表条件, then, else

另外两个逻辑算子是and和or, 这两个都可以接受任意数量的参数, 表现不一样, 对于and, 它会依次对参数求值, 一旦碰到一个是假的, 就会返回假即nil, 如果全是真的, 那就会返回最后一个参数的求值

对于or, 它会依次对参数求值, 返回第一个真的结果, 如果全是假的就返回假



定义一个函数, 需要使用类似关键字的defun, 它本身应该就是一个函数, 然后接受三个参数, 依次是函数名字, 参数表, 函数体语句这里的形参不需要使用quote运算子

类似形参这样的占位符叫做变数, 当变数代表函数的实参的时候又叫做形参



函数支持递归

假设我们要写一个函数, 检测一个元素是不是包含在列表内, 如果不是返回nil 如果是返回自这个位置开始的列表,那么可以使用递归来完成, 如下:

~~~commonlisp
(defun has_member (value a_list)
    (if (null a_list)
        nil
        (if (eql (car a_list) value)
            a_list
            (has_member value (cdr a_list))
        )
    )
)
~~~

基本上应该是这样子的, 从这里我们可以看到递归和函数, 以及函数返回值和调用



I/O

输出函数是format 接受大于等于两个参数, 第一个参数决定输出到哪, 缺省值是toplevel, 使用缺省值的话, 只需要将第一个参数设置为真就好, 第二个参数是一个字符串形式的模板, 剩余的参数是要填进模板的内容.在模板中使用`~A`代表一个要被填入的位置, `~%`代表换行符

例如:

~~~commonlisp
(format t "this is stan~A, ~% please say hello ~A" 2 (+ 3 4))
~~~

这个函数是有返回值的

输入函数是read, 当read函数没有参数时, 接受输入并返回, 例如:

~~~commonlisp
(defun ask (info)
    (format t "~A ~%" info)
    (read)
    )
~~~

这个函数接收一个输入, 返回值是输入内容



局部变量的定义

如果要定义局部变量, 使用let操作符, 接收两个参数, 第一个参数是要定义的局部变量所组成的列表, 每个局部变量的定义都要遵循`(var expression)`的形式, 第二个参数是要执行的语句. 返回值即语句的返回值

例如:

~~~commonlisp
(let ((x 10) (y 20))
     (+ x y)
     )
~~~

全局变量的定义

使用defparameter, 例如`(defparameter *glob* 10)`, 对于全局变量, 为了防止冲突, 习惯上我们经常使用`*`结束和开始

使用`defconstant`可以定义一个全局常量, `(defconstant max_value 30)`

检查一个变量是不是全局变量或者全局常量, 可以直接使用`boundp`, `(boundp 'max_value')`

赋值运算符:

`(setf var value)`, 如`(set *glob* 20)`, 如果第一个参数不是局部变量, 那么setf会把这个符号自动设置为全局变量, 即隐式的创建了全局变量

setf可以修改列表, 例如`(car x)`代表列表x的第一个元素, 所以如果`(setf (car x) 10)`, 可以把列表的第一个元素修改为10, 同时setf还支持多对同时设置`(setf a 10 b 20 c 30)`



迭代

