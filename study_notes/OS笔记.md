## OS笔记

这个笔记主要侧重于记录我尝试根据各种资料学习写一个极简的OS的过程。

首先列出环境与主要参考书目

之后会拷贝原来写的很凌乱的一些早期的笔记，然后才会继续正题。

要注意的是，这一部分肯定会和汇编语言有很多的联系，所以有些内容可能需要结合汇编语言笔记。那里面写过的东西这里就不会再赘述。



### 环境与参考书目

主要的参考书目是[一个64位操作系统的设计与实现](https://book.douban.com/subject/30222325/)，我并未找到电子版，所以买了实体书。

然后书中建议的是，使用Linux平台，然后需要使用nasm进行汇编的编译，语法的话实际上是Intel语法和AT&T语法的结合，至于原因书中有详细解释，我觉得这样其实很好，从多学一些东西的角度来说。然后c语言的编译器来自于GNU的gcc。另外还有早期的模拟运行环境，明显在早期的时候，需要很多调试，所以直接使用U盘和物理平台结合的测试方法并不合适，于是需要一个虚拟机，这里使用的是Bochs，据说用它的原因是它是一个带了调试功能的虚拟机，这就是和普通虚拟机软件不一样的地方。

为什么会利用Linux作为开发平台呢？其实我并没有找到特别的理由，可能就是Linux上面工具链比较完善。但是实际上我现在使用的是windows平台，主要原因是我不习惯于日常使用Linux，虽然我装了双系统，我也不想通过虚拟机在windows上使用Linux，然后，现在我也得到了一个Linux系统的服务器，但是我在bochs的安装上遇到了问题，安装失败了。

总而言之，现在我的工作环境是：

windows，需要安装nasm，然后安装bochs，然后将nasm编译的bin文件写入img的时候，在Linux上面会使用dd命令，在windows上面为了方便就会安装cygwin这个软件，这个软件可以让我们使用linux的一些命令，其中就包含了dd。

bochs需要一个配置文件，这里我从网上搞到了一个极简版的配置文件：

~~~
megs:32

romimage:file=$BXSHARE/BIOS-bochs-latest
vgaromimage:file=$BXSHARE/VGABIOS-lgpl-latest

floppya:1_44=a.img,status=inserted

boot:floppy

log:bochsout.txt

mouse:enabled=0

keyboard: keymap=$BXSHARE/keymaps/x11-pc-de.map
~~~

保存为`stan.bxrc`文件即可。

然后要使用bochs生成一个img光盘文件。过程在书中有细致描述，不再赘述了。

然后通过cygwin.bat打开cygwin的命令行，进入到合适的文件夹下，通过`dd if=boot.bin of=a.img bs=512 count=1 conv=notrunc`来进行写入，当然为了方便起见的路径什么的就自己搞好了。总之这里和书上没什么区别。

#### 启动虚拟机

可以先试用书上提供的第一个boot.asm，得到bin，写入img，搞好bochs的配置文件，然后运行`bochs.exe`，选择load加载配置文件，然后start即可运行，一切顺利的话应该就能看到start boot这样的输出。





ok，如一开始所述，下面会拷贝一些早期的资料收集，仅作为记录，可以直接跳过。

### 早期记录

其实网上很多教程写的很好，只是我不懂的看而已。第一部分，我需要知道计算机是如何启动的。

我的参考文献和博客很杂，这里不再一一举出。

只是这一块主要来自于[这篇博客](https://blog.csdn.net/langeldep/article/details/8788119)，下面的内容基本完全来自这篇博客，只是精简了而已。

整个启动过程分为四部分，其中第一部分可以认为是由硬件制造商控制的，属于硬件自动执行的，我们无法接管。其余三部分或多或少都能控制。

这四部分分别是BIOS,MBR,硬盘启动，操作系统

#### BIOS

电脑中有一块ROM，其中刷写着开机程序，第一件事就是执行这里面的程序，这个程序叫BIOS，全称Basic I/O System

BIOS其实包含了很多功能模块，首先他会执行硬件自检(Power-On Self-Test)，检查硬件是否满足开机需要，没有问题的话，BIOS会从启动顺序里面找到开始执行下一阶段启动程序的设备，这就是我们会设置的启动顺序。

依次尝试各设备，直至成功启动

#### 主引导记录(MBR)

启动顺序中的存储设备都有特殊的存储结构，具体而言就是存储设备的第一个扇区512个字节必须是一段主引导记录(Master boot record)，这512个字节有特定的结构，计算机会首先取出这前512字节放入内存指定位置。

由于MBR只有512字节，因而内容有限，主要作用就是告诉计算机去何处寻找操作系统。

MBR的结构：

```
1-446字节：调用操作系统的机器码
447-510字节：分区表
511-512字节：主引导记录签名
```

对于第一顺位的存储设备，计算机先读取其MBR，之后会检查511和512两个字节，只有当这两个字节内容为`0x55 0xAA`的时候才会继续，否则换第二个存储设备

硬盘是可以分区的，每个区都可以安装不同的OS，主引导记录需要知道应该将控制权交给哪个分区。

分区表共64字节，分为四项，各16字节，每一项都代表一个主分区。因此一个硬盘最多只能有四个主分区。

每个项的16个字节都包含6个部分：

```
（1） 第1个字节：如果为0x80，就表示该主分区是激活分区，控制权要转交给这个分区。四个主分区里面只能有一个是	 激活的。
（2） 第2-4个字节：主分区第一个扇区的物理位置（柱面、磁头、扇区号等等）。
（3） 第5个字节：主分区类型。
（4） 第6-8个字节：主分区最后一个扇区的物理位置。
（5） 第9-12字节：该主分区第一个扇区的逻辑地址。
（6） 第13-16字节：主分区的扇区总数。
```

因为扇区的总数只有4字节，所以主分区的扇区不多于2的32次方。

#### 硬盘启动

这个也是分情况的，三种情况，分别是使用了主分区进行启动，逻辑分区或者扩展分区启动，启动管理器启动。这相当于给了一些多样化的启动选项，具体是哪种，就是由MBR的前446字节确定的了。而我提到过的GRUB就是第三种情况。

具体的，看博客原文吧。

#### 操作系统

转交控制权给操作系统之后，就开始载入操作系统了。从内核开始。





#### Boot

DIY的第一步是尝试接管启动过程的第二步，自己写一个MBR，这里也经常被叫做自己完成boot code

MBR的全部512个字节并不是全都重要，如果要写，就必须知道这512字节的详细构造：

![MBR](D:/Test_Project/Create_OS/archive/study_notes/images/MBR.png)

这张图片来自于[这个网站](http://www.independent-software.com/operating-system-development-boot-sector-structure.html)，这个网站也是重要的参考

这里面重要的是BPB和EBPB，以及最后的两个字节





总而言之，至此，最重要也是最棘手的初始环境的配置算是已经搞定了。然后就可以照着书上的继续了。





### 一些说明

绝大多数的东西，不会再赘述，只会写一些让我疑惑的东西。

#### org问题

已知BIOS的最后，会读取一个扇区的数据进入内存的指定位置即`0x7c00`处，同时会设置`cs和IP`两个寄存器。这里看起来其实`boot.asm`里面设置`org 0x7c00`似乎没有什么意义，至少对于原本的第一个boot代码，去掉这一句似乎也没关系，检查编译得到的bin文件，似乎也的确没有区别。具体的更详细的研究可以看[这篇文章](https://blog.csdn.net/judyge/article/details/52333656)

