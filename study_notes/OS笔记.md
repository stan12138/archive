## OS笔记

这个笔记主要侧重于记录我尝试根据各种资料学习写一个极简的OS的过程。

首先列出环境与主要参考书目

之后会拷贝原来写的很凌乱的一些早期的笔记，然后才会继续正题。

要注意的是，这一部分肯定会和汇编语言有很多的联系，所以有些内容可能需要结合汇编语言笔记。那里面写过的东西这里就不会再赘述。



### 环境与参考书目

主要的参考书目是[一个64位操作系统的设计与实现](https://book.douban.com/subject/30222325/)，我并未找到电子版，所以买了实体书。

然后书中建议的是，使用Linux平台，然后需要使用nasm进行汇编的编译，语法的话实际上是Intel语法和AT&T语法的结合，至于原因书中有详细解释，我觉得这样其实很好，从多学一些东西的角度来说。然后c语言的编译器来自于GNU的gcc。另外还有早期的模拟运行环境，明显在早期的时候，需要很多调试，所以直接使用U盘和物理平台结合的测试方法并不合适，于是需要一个虚拟机，这里使用的是Bochs，据说用它的原因是它是一个带了调试功能的虚拟机，这就是和普通虚拟机软件不一样的地方。

为什么会利用Linux作为开发平台呢？其实我并没有找到特别的理由，可能就是Linux上面工具链比较完善。但是实际上我现在使用的是windows平台，主要原因是我不习惯于日常使用Linux，虽然我装了双系统，我也不想通过虚拟机在windows上使用Linux，然后，现在我也得到了一个Linux系统的服务器，但是我在bochs的安装上遇到了问题，安装失败了。

总而言之，现在我的工作环境是：

windows，需要安装nasm，然后安装bochs，然后将nasm编译的bin文件写入img的时候，在Linux上面会使用dd命令，在windows上面为了方便就会安装cygwin这个软件，这个软件可以让我们使用linux的一些命令，其中就包含了dd。

bochs需要一个配置文件，这里我从网上搞到了一个极简版的配置文件：

~~~
megs:32

romimage:file=$BXSHARE/BIOS-bochs-latest
vgaromimage:file=$BXSHARE/VGABIOS-lgpl-latest

floppya:1_44=a.img,status=inserted

boot:floppy

log:bochsout.txt

mouse:enabled=0

keyboard: keymap=$BXSHARE/keymaps/x11-pc-de.map
~~~

保存为`stan.bxrc`文件即可。

然后要使用bochs生成一个img光盘文件。过程在书中有细致描述，不再赘述了。

然后通过cygwin.bat打开cygwin的命令行，进入到合适的文件夹下，通过`dd if=boot.bin of=a.img bs=512 count=1 conv=notrunc`来进行写入，当然为了方便起见的路径什么的就自己搞好了。总之这里和书上没什么区别。

#### 启动虚拟机

可以先试用书上提供的第一个boot.asm，得到bin，写入img，搞好bochs的配置文件，然后运行`bochs.exe`，选择load加载配置文件，然后start即可运行，一切顺利的话应该就能看到start boot这样的输出。





ok，如一开始所述，下面会拷贝一些早期的资料收集，仅作为记录，可以直接跳过。

### 早期记录

其实网上很多教程写的很好，只是我不懂的看而已。第一部分，我需要知道计算机是如何启动的。

我的参考文献和博客很杂，这里不再一一举出。

只是这一块主要来自于[这篇博客](https://blog.csdn.net/langeldep/article/details/8788119)，下面的内容基本完全来自这篇博客，只是精简了而已。

整个启动过程分为四部分，其中第一部分可以认为是由硬件制造商控制的，属于硬件自动执行的，我们无法接管。其余三部分或多或少都能控制。

这四部分分别是BIOS,MBR,硬盘启动，操作系统

#### BIOS

电脑中有一块ROM，其中刷写着开机程序，第一件事就是执行这里面的程序，这个程序叫BIOS，全称Basic I/O System

BIOS其实包含了很多功能模块，首先他会执行硬件自检(Power-On Self-Test)，检查硬件是否满足开机需要，没有问题的话，BIOS会从启动顺序里面找到开始执行下一阶段启动程序的设备，这就是我们会设置的启动顺序。

依次尝试各设备，直至成功启动

#### 主引导记录(MBR)

启动顺序中的存储设备都有特殊的存储结构，具体而言就是存储设备的第一个扇区512个字节必须是一段主引导记录(Master boot record)，这512个字节有特定的结构，计算机会首先取出这前512字节放入内存指定位置。

由于MBR只有512字节，因而内容有限，主要作用就是告诉计算机去何处寻找操作系统。

MBR的结构：

```
1-446字节：调用操作系统的机器码
447-510字节：分区表
511-512字节：主引导记录签名
```

对于第一顺位的存储设备，计算机先读取其MBR，之后会检查511和512两个字节，只有当这两个字节内容为`0x55 0xAA`的时候才会继续，否则换第二个存储设备

硬盘是可以分区的，每个区都可以安装不同的OS，主引导记录需要知道应该将控制权交给哪个分区。

分区表共64字节，分为四项，各16字节，每一项都代表一个主分区。因此一个硬盘最多只能有四个主分区。

每个项的16个字节都包含6个部分：

```
（1） 第1个字节：如果为0x80，就表示该主分区是激活分区，控制权要转交给这个分区。四个主分区里面只能有一个是	 激活的。
（2） 第2-4个字节：主分区第一个扇区的物理位置（柱面、磁头、扇区号等等）。
（3） 第5个字节：主分区类型。
（4） 第6-8个字节：主分区最后一个扇区的物理位置。
（5） 第9-12字节：该主分区第一个扇区的逻辑地址。
（6） 第13-16字节：主分区的扇区总数。
```

因为扇区的总数只有4字节，所以主分区的扇区不多于2的32次方。

#### 硬盘启动

这个也是分情况的，三种情况，分别是使用了主分区进行启动，逻辑分区或者扩展分区启动，启动管理器启动。这相当于给了一些多样化的启动选项，具体是哪种，就是由MBR的前446字节确定的了。而我提到过的GRUB就是第三种情况。

具体的，看博客原文吧。

#### 操作系统

转交控制权给操作系统之后，就开始载入操作系统了。从内核开始。





#### Boot

DIY的第一步是尝试接管启动过程的第二步，自己写一个MBR，这里也经常被叫做自己完成boot code

MBR的全部512个字节并不是全都重要，如果要写，就必须知道这512字节的详细构造：

![MBR](D:/Test_Project/Create_OS/archive/study_notes/images/MBR.png)

这张图片来自于[这个网站](http://www.independent-software.com/operating-system-development-boot-sector-structure.html)，这个网站也是重要的参考

这里面重要的是BPB和EBPB，以及最后的两个字节





总而言之，至此，最重要也是最棘手的初始环境的配置算是已经搞定了。然后就可以照着书上的继续了。





### 一些说明

绝大多数的东西，不会再赘述，只会写一些让我疑惑的东西。

#### org问题

已知BIOS的最后，会读取一个扇区的数据进入内存的指定位置即`0x7c00`处，同时会设置`cs和IP`两个寄存器。这里看起来其实`boot.asm`里面设置`org 0x7c00`似乎没有什么意义，至少对于原本的第一个boot代码，去掉这一句似乎也没关系，检查编译得到的bin文件，似乎也的确没有区别。具体的更详细的研究可以看[这篇文章](https://blog.csdn.net/judyge/article/details/52333656)



### Boot

下面开始尝试第一次启动。

首先说明一下，环境问题已经说过了，我选择windows平台，之后我得到了帮助，成功在Linux上安装了bochs，但是最终无法运行，`cannot connect x display`这样的，我试过设置配置文件里面的display library为term或者nogui这样的选项，总之目标就是在命令行下使用bochs，结果呢，是不行，提示说这些选项不可用，我不确定原因是处在bochs的源码编译的时候还是bochs本身就要求必须使用图形界面。

所以现在我是在windows平台。

然后就是文件路径的问题，bochs自然是安装在一个单独的文件夹中，然后没被加入环境变量的话，bximage这样的命令就只能在它的文件夹下使用，条理起见，我倾向于将所有的代码文件，配置文件，光盘映像放在一个单独的文件夹内。配置文件是在启动bochs之后自由选择的，所以关键问题在于映像应该放在哪？bochs目录下还是配置文件目录下。我刚刚才发现，如果使用诸如上面贴出来的极简配置文件的话，a.img应该放在与配置文件同一目录下，这样非常让人满意，毕竟不用再每次拷来拷去了。

然后就是映像的问题。

问题在于，第一，为什么要特别使用bximage创建映像，为什么要特别选择fd或者hd？第二，dd有什么很特别的地方吗？第三，书中很快就开始使用了FAT12文件系统，已及mount挂载命令，这一切又有什么不同的？

这里，我想介绍一个windows平台下的工具--winHex，这个工具可以让我们查看任意文件的原始二进制内容。

首先就是第一个问题。选择fd或者hd发现最终得到的文件都是img文件，唯一的区别就是可选择的文件大小不同，用winhex检查，可以发现无论怎么搞，创建完之后得到的都是一个img后缀的，特定大小的文件，文件内容，所有的字节都是0，没有任何特殊信息。

所以这让我很怀疑bximage存在的意义，以及搞这些复杂选项的意义，事实上使用python我完全可以自己做到这些。

第二个问题，已经知道，boot.asm只是为了搞出一个512字节的完全指定信息的bin文件，也就是说boot.bin文件就是一个512字节的二进制文件，其实也的确知道dd命令只是原样将这512字节写入a.img的头部，即前512字节，作为主引导扇区。使用winhex检查也是的确如此，并没有任何特别指出。同样的这个过程使用python也完全可以实现。

第三个问题让我也非常的疑惑，我的步骤是首先，我知道这个挺复杂的，对于完全不懂的我来说，所以我会首先尝试直接使用书中提供的源码，先跑通了再说。然后我就被卡到了，cygwin无法使用mount挂载命令，经过一番搜索，网上的说法cygwin只是尽量在win上面模拟出一个linux环境，但是后面用的还是win提供的接口，总之就是mount就是不太能行。于是该怎么办？我完全不懂这个过程是在干嘛，自然我也不知道该使用什么工具在win上面完成这个过程。于是我采用了很无奈的迂回策略，我会在linux上面完成全部过程，然后把得到的img再弄回win，然后再跑。现在的结论是，我终于跑通了。

接下来要做的就是通过winhex进行对比，搞懂这个过程实际上到底干了什么，搞懂FAT12文件系统，然后努力使用python取代这一系列的费劲的命令。进行ing....

