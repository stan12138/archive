## 网络编程

> 17.7.7  by stan


### 整体印象
所熟知的就是客户端与服务器的通信是使用HTTP协议的，客户端是浏览器，服务器指的是服务器软件，其实二者最重要的作用就是从http报文中解包出必要的信息，或者将要发送的信息使用http协议打包，然后发送，由于涉及到报文的解析，这个过程很是繁琐，我知道你并不想接触这样的最底层。

那么在高级一点，已经有浏览器这个自然存在的客户端了，因而不需要为客户端而发愁，那么服务器呢？最重要的就是怎样得到一个服务器，我又该如何与服务器交互，得到浏览器请求或发送的信息呢？这里出现的就是WSGI，首先，WSGI是针对python的，其他语言也存在类似的东西，但是都不叫这个名字，WSGI全称服务器网关接口，只要得到一个支持WSGI的python服务器，然后写一个WSGI函数，WSGI就可以运行了： 

~~~python
def application(environ, start_response):
	start_response('200 OK', [('Content-Type', 'text/html')])
	return [b'<h1>Hello, web!</h1>']
~~~

以上就是一个WSGI函数，服务器会传递给这个函数两个参数，前一个是一个字典，它包含了所有从http报文中解析出来的请求信息，后者是一个负责发送回应的函数。  

是不是很完美，正合我意？我们既不需要解析协议，又能拿到所有来自浏览器的信息，同时只需要把我们要返回的信息交给start_response就可以，完全不需要封装。  

### 测试
在python里面已经自带了一个提供测试的wsgi服务器，我们只需要提供上述函数，他就可以工作了：
~~~python
from wsgiref.simple_server import make_server
# 导入我们自己编写的application函数:
from hello import application

# 创建一个服务器，IP地址为空，端口是8000，处理函数是application:
httpd = make_server('', 8000, application)
print('Serving HTTP on port 8000...')
# 开始监听HTTP请求:
httpd.serve_forever()
~~~
是不是很完美？


#### 网络框架
那么网络框架的存在又有什么意义呢？  

使用wsgi存在最大的两个问题，第一我们需要写很多很多的代码区分识别浏览器请求不同页面时的处理函数，很繁琐，虽然很容易做到，第二我们要以字符串的形式提供巨大的html页面，甚至是css，javascript。  

这便是网络框架存在的意义了，它可以以一种很简洁的方式让我们设置如何应对不同的页面请求，同时它们也往往会融合一些模板系统，让我们来以更方便的形式返回html页面，那么，什么又是模板系统呢？

#### 模板
对于一个纯粹的html页面，明显他几乎是不可更改的，那么它产生的页面就是一个静态网页，换句话说里面的内容不能灵活的更新，要想更新几乎必须要重写一个新的页面，这很不合理。

于是便有了模板，我们只需要根据模板系统的语法，在特定的位置用变量去替代固定的字段，然后使用模板提供的函数我们就可以灵活的，动态的更新这些字段的值。  



当然以上所述只是这几个东西的核心功能，事实上一个真实的会比这个要复杂，提供更多的功能。


#### 自己动手
从上面所说的可以看出，最关键的几个大块就是：

浏览器

服务器

WSGI

网络框架  

这些东西我们是不是都可以手工完成一个呢？毫无疑问，我们有socket这样负责接发信息的最底层模块，那么理论上我们就可以使用它完成一个浏览器，服务器。

但是呢，明显，浏览器这个东西没啥必要去手动做，到处可得。

那么服务器呢？是的，我的确可以手动完成一个服务器，详情见教程[自己动手搭建服务器](https://my.oschina.net/leejun2005/blog/486771)

WSGI自然就包含在服务器之中了

网络框架呢？自然也是可以的，详情见廖雪峰的python教程的实战部分。  


## 服务器

这里我要记录我是怎么写出来一个WSGI服务器的  

#### 基础
最基础的部分只是建构在基本的socket上面的，与之前建立一个TCP服务器是一个完全一致的流程，这里要注意第一个点，<font color='red'>返回给浏览器的响应必须严格满足HTTP响应报文的格式</font>

简单而言，首先使用send或者sendall发送回去的必须是bytes，其次报文是要分块的，头和主体，头部分行，第一行的格式必须是：版本 状态码 状态字符串，接下来的几行是附属信息，注意必须要包含一个关于内容类型的说明，否则浏览器是无法显示回应的，头和主体之间必须包含一个空行，主体部分只是简单的把html等转为二进制发送回去就好了。下面是一个示例 ：

`b'HTTP/1.1 200 OK\r\n'+b'Content-Type: text/html\r\n\r\n'+二进制的html报文`

浏览器的所有请求相关的信息全部写在收到的浏览器的消息中，对于一个wsgi接口，我们必须解析这些字符串，然后把它转换为字典的形式。  

我不想说太多了，总之在写成类的形式的时候，会把连接，运行，解析，发送，断开，关联application等都各自写成一个方法。看代码吧

#### 一个参考实现

~~~python
import socket

class Server :
	def __init__(self,host='',port='8000') :
		self.host = host
		self.port = port
		
		self.server = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
		self.server.bind((self.host,self.port))
		self.server.listen(5)
		self.life = 2
	def set_app(self,application) :
		self.wsgi = application
		
	def run(self) :
		while self.life :
			self.client,self.cli_addrs = self.server.accept()
			self.handle_request()
		self.server.close()
		
	def handle_request(self) :
		self.cli_message = self.client.recv(1024)
		self.cli_message = self.cli_message.decode('utf-8')
		self.env = {}
		self.parse_request(self.cli_message)
		self.reponse_body = self.wsgi(self.env,self.reponse)
		
		self.send_close()
	def parse_request(self,message) :
		message = message.split('\r\n')
		
		head = message[0]
		head = head.split()
		if len(head)==3 :
			self.env['method'] = head[0]
			self.env['path'] = head[1]
			self.env['version'] = head[2]
		del message[0]
		for i in message :
			body = i.split(': ')
			if len(body) == 2 :
				self.env[body[0]] = body[1]
		
	def reponse(self,code,header) :
		self.code = bytes(code,'utf-8')
		self.header = header
		
	def send_close(self) :
		try :
			res = b'HTTP/1.1 '+self.code+b'\r\n'
			h1 = ''
			for i in self.header :
				if len(i)==2 :
					h1 += i[0]
					h1 += ': '
					h1 += i[1]
			res += bytes(h1,'utf-8')
			res += b'\r\n\r\n'
			res += bytes(self.reponse_body,'utf-8')
			#print(res)
			self.client.sendall(res)
			self.life -= 1
		finally :
			self.client.close()
			#if self.life < 1 :
			#	self.server.close()

def make_server(host,port,application) :
	serve = Server(host,port)
	serve.set_app(application)
	return serve

~~~

#### 几个重要问题的说明

1. 这个版本的是在ipad上面编写测试的，所以因为我找不到终止服务器的合理方法，所以我增加了一个life属性，作为连接计数，一旦次数超过了life就会强制关闭。  
2. 到这里为止，我还没有处理请求链接的处理问题
  3. 重中之重，浏览器是怎么请求css,javascript,img的呢？答案是只要你在html里面写了这些连接，浏览器会自动发送额外的请求，有几个链接就会额外请求几次，请求信息上会附带着请求的路径，要求的内容等，注意一个巨坑的地方，因为我把life设置成了2,所以如果页面里面有一个以上的链接就收不到响应了，记得改一下哦。

<font color='red'>靠，为什么iphone和ipad都发不回来表单数据，为什么？</font>

### <font color='red'>Give up</font>

我不想接续写服务器了，没前途，功能巨弱，毛病巨多，搞不下去了。
作为留念，此处留下目前的进度：
主体文件有三个，My_server,server_connect,app.第一个是服务器的主体，负责接收，解析，发送，同时提供了简化版的wsgi接口；第二个类似于简化到极点flask框架，提供与flask类似的url处理函数设置方法；使用时只需要建立第三个文件，设置一些url处理函数即可。

这三个文件要放在同一目录下，在此目录下再设一个static_file文件夹，用于放置所有的html,css,js文件。
一言蔽之，这只是一个趣味性的，用来了解大概工作过程的，完全不可用的服务器加网络框架，不提供多线程，异步，不提供动态网页模板，不支持多页面，不支持数据库，总之啥也干不了。
Bye~~



### 解决一个问题

上面没有明说，但是已经写完的服务器有一个巨大的问题就是极其难以关闭，今天我终于解决了关闭问题，使用的方式包括多线程和signal信号捕捉

方法简单来讲就是：

不修改sever_connect和Myserver，直接修改app文件，首先构造一个signal处理函数，用来捕捉ctr-c，这个就不必详细说了吧，在python笔记里面有

然后，把Application.run放在一个线程里面运行，并把这个线程设置为守护线程，主线程不做任何工作，只是监视全局变量，捕捉到ctr-c后退出，这种方法快捷，迅速，灵敏，干净，代码如下：

~~~python
from server_connect import Application
import threading,signal

stop = False

def signal_handler(a,b) :
	global stop
	stop = True
	print('got signal')

signal.signal(signal.SIGINT, signal_handler)



ap = Application()

@ap.set_url('/')
def index() :
	with open("static_file/first.html",'rb') as fi :
		rep = fi.read()
	#print('got html file')
	return rep


s = threading.Thread(target=ap.run, args=('',8000))
s.setDaemon(True)
s.start()

while not stop :
	pass

ap.ser.server.close()

print('already close')
~~~



#### 关于文件传输某些记录

我计划将自己写的服务器转移到ipad上面，同时为了应对没有ctr+c的这种问题，对服务器的关闭方式做了一些改变，改成了输入stop即可关闭（暂时是这样），如果想通过文件上传，将文件传输到pythonista，那么要注意的问题是：表单的enctype必须修改，如何解析出文件。

==这里插入一句，你猜在ios上面运行`<input type='file' name='stan'/>` 会出现什么？它会打开一些支持文件查看的应用，如照片，pdfExpert Document等，这大概也就意味着我们可以直接在pythonista里面操作这些应用的文件==

书接上文，这里面最麻烦的大概就是如何从报文中解析出文件，事实上python的标准库里面提供了几个参考服务器，有CGI的和WSGI的，它们应该都能解析出文件，但是前者复杂，后者我不知道他解析出来的文件会存在哪



找到了，存在environ['wsgi.input']中，但是似乎适用wsgi并没有什么用，因为这个里面存的并不是解析好的文件，而是包含了boundry等信息的，还是要自己解析，所以，放弃了。还是自己动手吧。

我计划使用正则表达式提取报文信息，然而，我几乎要被环视搞疯了。



#### 又解决一个大麻烦

最初，可以称得上我的心头大患的两个问题是：1、如何关闭服务器 2、recv(buffersize)里面的buffersize怎么确定

第一个问题已经得以解决

今天，17.9.18日晚，我成功找到了完美的解决第二个问题的方法。

其实，从和老大的一些讨论之中，答案已经初见端倪，他提醒我一点，凡是POST，全都包含了content-length这一属性，可以作为我们读取的参考，而对于get，我们完全没必要获取报文主体

我首先测试了python提供的wsgi服务器，发现它可以完美地接受体积十分巨大的multipart/form-data表单，这告诉我，在标准库中存在着完美的解决方案。

我首先理清了类的继承关系，wsgiref.simple_server <= http.server <= socketserver

进而我大概分析出了各个类和函数的相互调用关系，和调用顺序，总之花了相当的时间，我最终找到了答案。

首先，说明一个我之前没有注意到的东西：file.readline(size)方法的工作方式，它可以读取文件的一行，size给出了应该读多少，读取的真正长度为min(size,one_line_length)

而，socket.socket提供了一个方法，makefile，这个方法可以把socket变成一个类似于文件的存在，于是我们现在接受的方式将不再是recv，而是直接从这个文件读取，我们首先使用readline(size)获取首行，然后是headers，拿到content-length之后，再读取主体即可。

肿么样，是不是很牛叉，我会尽快将我的服务器更换至这种新的方案。

但是，python称它的标准模块提供的一系列server模块为simple server，但是这个服务器和我写的相比，绝对绝对称得上巨复杂的，所以，即便我做完这些改进，我的依旧只是一个示范，原理性的,非标准的wsgi服务器。