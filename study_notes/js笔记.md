## JavaScript笔记

> --by stan 17.7.19

&lt;font color='red'>最佳参考书为JavaScript高级程序设计（第三版）&lt;/font>

### 概念

首先澄清几个概念，ECMAScript就是标准化的Js,事实上现在人们通常认为二者是同义词，但是呢，更严格地讲，Js的范围要更广一些，他应该包含基本的Js,DOM（文档对象模型），BOM（浏览器对象模型）
DOM似乎是完成了js和html,css的接口，甚至是一些鼠标事件

### 数据类型

下面写的很混乱，在这里重新声明一下，js的数据类型大概可以分为5种：Undefined,Null,Bool,Number,String.还有一个复杂的数据类型，叫做Object,Object本质上是一组无序的键值对，类似于python里面的字典

### 变量与类型

*   变量统一使用var声明，使用动态类型，与python一致

*   区分大小写，html不区分大小写，但是它的标签和属性在js中必须写成小写。

*   注释使用//和/**/，与C语言一致

*   分号不是必须的，但注意保持风格一致，但是在某些位置句尾还是必须要分号的，介于我还不是老手，所以建议每个句尾都加分号

#### 数字

数字同样不分类，十六进制使用0x或0X的前缀，不是所有的标准都支持直接写八进制，支持的使用0开头，所以建议不要用
浮点数支持e或E的用法
四则运算为+-*/，取余%，似乎其他复杂运算都要调用库，Math库，留待后述
溢出不报错，定义了Infinity。另外还用一个NaN。
注意不要去试探她的浮点数的精度，譬如0.3-0.2并不等于0.2-0.1  

#### 时间

js里面特别提供了一个日期或时间类型，它提供了一些方法，可以让我们快速进行计算，例如快速计算两个事件之间的毫秒数，可以直接使用减法。  

#### 字符串

js的默认编码为utf-16
单引号和双引号都可以，与python一致
可以拆分为多行，但行尾必须使用\续行
转义字符一致，暂不叙述
字符串支持加法，另外还有很多的属性和方法，例如length属性
支持索引[]
自带支持正则表达式，正则表达式使用两条/包围，第二条的后面还可以跟一个或多个修饰的字母  

#### 布尔值

保留字true,false

#### 缺失值

null,undefined
前值为空，后者就是未定义的意思  

#### 全局对象

？？？

#### 类型转换

这里的类型转换似乎要灵活得多，暂且略过，只保留字符串与数字
数字有一个toString()方法，并接受一个参数指定基数，还有更高级的toFixed,toExponential,toPrecision等方法，暂不详述。
将字符串转换为数字有parseInt(),parseFloat()等函数，很智能很高级，暂不详述
总之类型转换很灵活，很复杂，东西很多还没说  

#### 作用域

在局部作用域里面可以访问其相对全局作用域的变量，并且可以直接更改，不需要特别声明，这一点和python不同。
函数是一个局部作用域，这一点和类C语言一致，但是js中不存在块级作用域，例如在C中，当你在一个for语句，if语句内部声明了一个变量，那么你将可以在花括号内部访问该变量，但是在花括号结束时，该变量就被销毁了，但js不存在这一个作用域，for等的内部声明的变量，在外部依旧存在

### 全局对象

有一个很奇特的叫全局对象的东西，指的是一份js代码文件，也可以使用this自我引用，文件里面所有的全局变量都是this的一个属性，不使用var声明的可以使用delete删除，等等，暂不需了解太多  

### 表达式运算符

*   创建一个对象要使用new关键字
*   ++ -- += -= *= /=
*   `+ - * /`

*   == ! &amp;&amp; ||  &lt; &gt; &lt;= &lt;=
  均类似于C语言
*   还有一个什么鬼的`===`是恒等的意思，`！==`恒不等,暂时也用不上，就不深究了
*   in和instanceof暂时略过
*   还有一个神奇的eval()函数，可以直接运行字符串形式的源代码，暂不表
*   有三目运算符?:
*   typeof运算符，测量类型，如 typeof x；关于返回值的情况暂时略过
*   delete运算符，删除一个对象的属性或者一个元素
*   void运算符，可以强制去掉返回值

### 语句

#### if

~~~c
if(expression)
{
}
else if(expression)
{
}
~~~

#### switch

我没有用过switch,所以暂时不写

#### while

~~~c
while(expression)
{
}
~~~

#### do while

~~~c
do
{
}
while(expression)
~~~

#### for

~~~c
for(init;test;update)
{}
~~~

#### for/in

~~~c
for(variable in object)
{}
~~~

#### 另有

跳转部分的标签，break，continue，return等

#### 异常处理

throw try/catch/finally等，暂不表

#### 其他语句

with  debugger  "use strict"暂不说  

### 数组

js里面的数组更类似于python里面的列表，元素类型不限。
可以随意增长，只需要对后面的索引赋值即可，总之其索引方式异常灵活。
稀疏数组，略过
数组都有一个length属性  

*   向尾部增添一至多个元素，调用push方法*   删除用delete操作符，但是并不会改变length，而是让数组变成了稀疏数组。

*   因为稀疏数组的存在，让遍历显得略微复杂，暂不提*   数字的方法也暂时略过

###  函数

~~~c
function test(a,b)
{
	var c = a+b;
	return c;
}
~~~

##### 函数的参数

函数的参数的行为很有意思，无论你在函数的定义中写了几个形参，函数调用时从来不在意你传入了几个参数，传入也行，不传也行，数目与形参一致可以，不一致也行。这一切都是因为参数在内部是通过一个数组表示的，函数只是接受了这个数组，从不在意数组的值。在函数内部是可以通过arguments这个对象来访问所有的参数，通常情况下我们会使用arguments.length这个属性来得到参数的数目，通过[]索引来获取每一个参数。另外特别需要注意的就是，arguments与参数永远保持同步，换句话说arguments[1]永远与第二个实参保持一致，两者的改动也会保持一致，虽然两者对应的并不是同一块内存。

~~~c
function test(num1,num2)
{
	if(arguments.length==1)
	{
		alert(num1);
	}
	else if(arguments.length==2)
	{
		arguments[1] = 10;
		alert(num1+num2);
	}
}
~~~

这个函数的行为表现为传入一个参数的时候会输出这个值，传入两个参数的时候会输出第一个参数加10的结果，因为通过arguments[1]可以直接修改num2的值



### 内存管理

js内部也有自动的垃圾收集机制，但是事实上os分配给浏览器的内存数量比桌面程序要少，因而当你不再使用一个数据的时候，最后可以通过手动解除引用将其内存释放一下，方法为将变量的值设置为null  


### 引用类型

所谓引用类型与我一直以来所说的构造类型一样，之所以要特别声明这个类型就是在于复制时的表现，如果一个变量是基本类型，那么在执行a=b这样的操作时它们分别指向两块内存，改变一个值不会引起另一个值的改变，但是如果一个一个变量是引用类型，那么执行复制操作的时候，两个变量事实上指向了同一块内存，改变一个会引起另一个的改变。向函数传参的时候的表现也是这样的.  


    <font color='red'>靠！！！！刚才写的几百字竟然丢了，一直很谨慎，竟然还是中招了</font>
##### Object类型

object类型会是一个常用的引用类型，创建的方法有两种：
1、使用关键字new,`var person = new Object();`，然后直接定义属性
2、使用字面值直接定义：

~~~c
var person = {
  name = 'stan',
  age = 29
};
~~~

当使用第二种方式创建时，属性名字可以是变量名也可以是字符串，如果是数字，则会被自动转换为字符串

另外这种对象也是向函数传递不定数量的大量参数的一种很好的方式  

索引属性的方式有两种，一种是`.`，另一种是[]索引，后者必须使用字符串进行索引，第二种方式可以实现一些特殊属性名的索引，例如包含空格的名字，除此之外实质上是建议使用第一种索引的

##### Array类型

所谓Array类型实际上就是数组，之前已有部分说明，这里再详细记录一次。
创建方式和Object一样，也是两种：
1、var l = new Array();可以传入参数，当传入一个数值时，代表数组的长度，也可以传入项
2、var l = [1,2,3]; 不要企图使用多余的`,`来增加数组的长度，不同的浏览器解释方式不同  

*   索引同样使用[0~n],当设置索引不存在的项的时候会自动增加

*   数组具有length属性，不仅可读，还可写，如果将其写长，会增加undefined值，如果缩短会把后面原有的值变成undefined

*   检测对象是不是数组很重要，使用Array.isArray(value)来检测

###### 栈与队列

数组同时也实现了站和队列的操作，实现的方式为提供了几个方法，`person.push()`可以接受1~n个参数，把这些量依次加到数组的末端，`person.pop()`可以弹出数组的最后一个值，并缩短数组长度，`person.shift()`可以弹出数组的第一个值，并缩短长度。额外的又提供了另外一个特殊的方法，`person.unshift()`接收多个参数，可以把它们依次加入数组的首部，同时增加长度

###### 排序

数组也集成了排序，数组提供了两个方法进行排序，`reverse`和`sort`,前者可以将数组反序，后者默认将数组升序排列，但是后者是通过将数组项转换为字符串，然后对字符串按位升序得到的，所以他会认为5大于15。因此我们需要传入一个比较函数，sort方法将会使用这个比较函数对每两个值进行比较，进而排序。比较函数需要满足的要求是：当第一个参数小于第二个时，返回负数，相等返回0，大于返回正数。如果比较函数满足这个要求，sort会将数组升序排列。因而降序也有两种方法，一是在比较函数上做手脚，一个是先升序排列，再reverse。这里提供两个样例：

~~~javascript
function compare(value1,value2)
{
  if(value1>value2) return -1;
  else if(value1==value2) return 0;
  else return 1;
}

function compare(value1,value2)
{
  return value2-value1;
}

a = [1,10,5,15];
a.sort(compare);  /没有返回值，直接将a降序排列
~~~

###### 其他方法

-   concat(),用于利用本数组创建一个新数组，以返回值的形式给出，如果不传入参数则是创建一个不同内存块的相同数值的数组，如果传入参数则会将这些项添加到新数组的尾部，如果传入一至多个数组，会自动解包，然后逐项添加。
-   slice()，用于使用本数组中的几个项创建一个新数组，参数为1或2个，一个参数时是从该项到最后一项，两个参数的话分别代表首尾，包含起始项，不包含尾部。如果传入参数是负数，那么实际上代表的是数组长度加上该值的项。
-   splice(),这个据说是最为强大的方法，接受2~n个参数，如果只有两个参数，代表从v1开始，删除数组中的v2项。如果将删除的项数设置为0，同时传入更多的参数，将会将第3至n个参数插入数组，从位置v1开始。如果同时指定了删除的项数，那么相当于替换。需要注意的是插入项不能是数组形式，他不会自动解包。
-   indexOf(),lastIndexOf(),这是两个查找方法，他们均可以接受两个参数，第一个是要查找的项，第二个是查找的起点，第二个参数可选。两者不同之处在于前者从头开始查找，后者从尾开始。同样的查完或者查到第一个结束，不会找到所有的位置。查找失败返回-1。需要特别注意的是，这里的查找是全等，也即同一块内存，因而自行构建的两个看起来一样的引用对象是查不到的。
-   迭代方法，数组定义了5个迭代方法，每个方法都接受两个参数，第一个是要在每一项上运行的函数，第二项是运行该函数的作用域对象**不明白啥意思**。其中传入的函数接受三个参数：数组项的值，位置，数组对象本身。函数的返回值对于不同的迭代方法有不同的要求。
    -   every(),如果对每一项函数的返回值都是true,则该方法返回true
    -   filter(),返回一个数组，数组中的项是函数返回值为true的项
    -   forEach(),只是运行函数，没有返回值,类似于一个for循环，所以有啥用？
    -   map(),返回一个由函数返回值组成的数组
    -   some(),如果有至少一项的函数返回值为true，则返回true
-   归并方法，提供了两个归并方法，reduce(),reduceRight(),两个方法均会逐个迭代数组里的所有值，区别在于前者从前往后，后者从右开始。均接受两个参数，第一项是要在每个项上执行的函数，第二个是归并基础的值，可选。函数接受四个参数：前一个值，当前值，位置，数组对象。这个函数的返回值会作为下一项执行函数的第一个参数。如果只给方法提供了一个参数，那么方法会自动从数组的第二项开始执行，并把第一项作为迭代函数的第一个参数传入。如果提供了两个参数，则会从第一项开始执行，并把第二个参数作为迭代函数的第一项传入。

##### Date类型

使用`new Date()`可以创建一个时间类型，不传入参数创建的是当前时间，支持传入一个微秒数，以创建一个特定的时间，时间基点为1970.1.1 00：00：00.  

为了简化又特意提供了两个方法，其中的Date.parse()接受特定格式的日期字符串，然后返回微秒数，但是标准中并未规定字符串的格式，因地区而异，因而我觉得这并不是一个好的方法。

Date.UTC(),该方法接受一系列的参数，分别代表：年，基于0的月份（0是1月），天（1~31），小时（0~23），分钟，秒，毫秒。参数中年月必需，天默认是1，其他默认0.

日了狗了，在chrome中测试，UTC方法的默认时区是格林尼治时间。

绕了一圈才发现实例化的时候竟然支持与UTC一致的参数传入，而且时区会设置为本地时区。

-   Date.now()，返回调用这个方法时的毫秒数

###### 继承的方法

Date类型重载了几个方法，分别是toLocaleString(),toString(),valueOf()，分别是转换为本地格式的日期字符串，带时区信息的字符串，毫秒数。似乎没啥太多用处

###### 日期格式化

大概有那么5个方法，大多输出格式因浏览器而异，所以没太大用处

除了上面说的之外，还有很多方法，不再提及

##### RegExp类型

RegExp是用于支持正则表达式的

这里使用的正则表达式的格式类Perl:`var expression = /pattern/flage;`

其中的pattern即正则表达式，flage是一些行为标志，支持三种：

-   g,全局模式，匹配所有的，即全局模式，而非在发现第一个时停止。
-   i,不区分大小写。
-   m，多行模式，会继续查找下一行，不因行的结束而停止

例如：var pattern = /.[bc]at/gi;

###### 属性

有几个用来查看实例属性的属性：

-   global,是否设置了g
-   ignoreCase,是否设置了i
-   multiline,是否设置了m
-   lastIndex
-   source

这些都没有实用价值

###### 方法

重要方法有两个，

-   exec(),接收一个要应用模式的字符串为参数，返回第一个匹配项的数组信息，无匹配返回null。返回值是一个特别的数组，有两个特殊属性，index,input，前者代表匹配项在数组中的位置，后者就是exec的参数。exec每次只会返回一个匹配项，返回值数组的第一项是匹配到的字符串，如果模式中有捕获分组，则数组的其他项是捕获组，没有捕获的话只有一个。如果正则表达式开启了全局模式，则每次调用exec会匹配下一个位置，如果没开，每次调用匹配的是同一个位置。
-   test(),接收被应用的字符串，返回值代表匹配到与否

注意，这似乎是一个状态机之类的，如果开了全局模式，然后先调用了一次test,然后再调用exec，他也会把第一个跳过

###### 其他属性

还有大概6个被称作构造函数属性的属性，每个属性有两个名字，一个长属性名，一个短属性名，大概暂时用不到，我也不再详细记录了

-   input  $_
-   lastMatch  $&
-   lastParen  $+
-   leftContext  $`
-   multiline   $*
-   rightContext  $'

##### Function类型

函数事实上是对象，既有属性又有方法，函数名只是一个指向函数对象的指针。

正因为函数是对象，我们也可以使用实例化Function类来创建一个函数，虽然这种方式极不推荐。

解析器有一个叫做函数声明提升的过程，这样即便函数写在调用之后，也还是可以工作，但不推荐这样做，函数声明和函数表达式不一样，如果以函数表达式创建一个函数，就绝对不能写在调用之后。

1.  函数的内部对象

    一个内部对象是前面所说的类数组参数对象arguments,不再多说，补充一下，arguments有一个callee属性，它是一个只想拥有该arguments对象的函数，这在某些时候有些用处。

    另一个是this,指向拥有该函数的对象。

2.  函数的属性

    -   length,代表函数希望接受的参数的数量
    -   prototype,暂时我也不太懂，也似乎对我还没啥用

3.  函数的方法

    -   apply()
    -   call()
    -   bind()

    说是这几个方法都是用来扩充函数的作用域或类似作用的，暂时也没啥用

##### 基本包装类型

布尔类型，数字，字符串，如前所述是基本类型，但是它们的确可以访问一些特殊的方法和属性，这是因为实际上在创建的时候解释器自动进行了一个创建对象并销毁的过程。

因而存在Boolean(),Number(),String()对象，但是，对于前两者而言，基本上不建议使用，没啥用，有时还会造成误解。

###### String类型

我觉得暂时没必要写很多字符串的方法，反正也记不住，跳过吧



##### 单体内置对象

大多数所谓单体内置对象都已经介绍过了，就是内置类型，这里再介绍两个

###### Global对象

似乎并没有太多适合现在研究学习的，只有一个前面提到过的eval方法

window对象，全局作用域里面的所有变量和函数都是window对象的属性

###### Math对象

提供数学计算

-   属性

    这里提供了很多常用的常数，例如Math.E,Math.PIdeng

-   方法

    -   min(),max().特别的如果想要找到数组的最值，不能简单的传入，需要这样Math.max.apply(Math,array)
    -   舍入，ceil(),向上舍入，floor(),向下，round()四舍五入
    -   random(),[0,1)之间的随机数
    -   其他的数学函数，如abs,exp,log,pow,sqrt,sin,atan2等，不多说

    ​

### 面向对象

书中在原型模式创建类，继承这两个部分花费了很多笔墨，也相对而言比较难懂，我也暂时用不上这么深入的东西，因而暂不记录。

-   考虑如何创建一个对象。

~~~javascript
/实例添加
var person = new Object();
person.name = 'stan';
person.age = 23;
person.sayname = function(){
  alert(this.name);
};

/字面值
var person = {
  name : 'stan',
  age : 23;
  sayname : function()
  {
    alert(this.name);
  }
};

/如何创造一个可供实例化的对象呢？
/
/工厂模式
function Person(name,age)
{
  var o = new Object();
  o.name = name;
  o.age = age;
  o.sayname = function()
  {
    alert(this.name);
  };
  return o;
}

/构造函数
function Person(name,age)
{
  this.name = name;
  this.age = age;
  this.sayname = function()
  {
    alert(this.name);
  }
}
~~~

总而言之，你只是想构建一个特殊的结构体，那么推荐前两种，如果是想创建一个类，那么推荐最后一种。

-   属性设置

    -   对象的每个属性都可以设置4种数据属性，用来控制某个属性的行为特征，这四个属性是：`Configurable 可否delete并重新设置`,`Enumerable 可否通过for-in循环返回属性`,`Writable 可否修改属性的值`,`Value 包含这个属性的值`

        这四个属性的前三个默认值为true,最后一个默认undefined。

        如果想要修改某个属性的默认值，必须使用一个特殊的设置函数`Object.defineProperty()`这个方法接收三个参数：属性所在的对象，属性的名字，一个描述符对象。

        ~~~javascript
        var person = {};

        Object.defineProperty(person,'name',{writable:false,value:'stan'});
        ~~~

        经过上述设置，person.name将只能读，无法再修改了。

        值得注意的是，按照书上所说，属性是可以通过上述方法反复修改的，但是，如果把configurable设置为false之后就会受到约束。但是我暂时实验反复修改会抛出错误，所以，暂时只是知道就好了，具体行为有待继续研究。

    -   另外属性还可以设置四个访问器属性，这四个属性控制其被访问时的特征（这里具体的属性数量我还不确定，四个里为啥有两个重复的），先说两个：

        这两个同样需要通过Object.defineProperty()来设置，分别是get和set,设置方法如下所示：

        ~~~javascript
        var book = {
          _year : 2004,
          edition : 1
        };

        Object.defineProperty(book,'year',{
          get:function(){
            return this._year;
          },
          set:function(value){
            if(value>2004){
              this._year = value;
              this.edition += value-2004;
            }
          }
        })
        ~~~

        这时当你访问book.year时，get就会起作用，当你试图设置book.year时，set函数就会起作用。

    大概属性设置就是这样，甚至暂时根本用不上。

    ​

面向对象的更深入的部分暂时不再继续了

### 函数表达式

常用的函数创建方式叫做函数声明，还有一种创建方式叫做函数表达式。

常用的函数表达式的形式为：

~~~javascript
var functionname = function(args){
  /函数体
}
~~~

这是创建的函数也叫匿名函数。

我讨厌递归，跳过

#### 闭包

所谓闭包，就是指一个函数，它可以访问其他函数的局部作用域的变量。

书中做了大量的解释，包含作用域的作用域链机制，我并未深入研究。

暂时到这。

#### 块级作用域

呃，有点不知所云

#### 私有变量

这里有点意思，前面一直在强调，函数也是对象，这句话是什么意思？对象的特征是什么？所谓对象，最明显的特征是具有属性和方法，所以这意味着可以为一个函数再创建一个方法，这个时候函数就颇类似于一个类了，也可以实例化：

~~~javascript
function Person(name)
{
  this.get = function()
  {
    return name;
  };
  this.set = function(name1)
  {
    name = name1;
  };
}

var person = Person('stan');
alert(person.get());
person.set('nats');
~~~

##### 模块模式

没搞懂。。。。。



---

>   开始新的一部分



## BOM

