## 汇编语言

呃，我想写OS，如果要从boot loader开始的话，那么似乎就必须要使用汇编语言。我如果不了解这种东西的话，又不愿意动手，所以，我决定看看汇编，反正又不赶时间。

其实我现在依旧对整个体系不了解，我知道的大概是这样的，首先汇编是针对特定平台的，例如我现在的目标就是x86平台的。然后呢，还涉及到了语法问题，Intel语法和AT&T语法是不一样的，我觉得前者更加顺眼。再后就是编译与编译器问题了，据我所知现在有MASM，NASM，GAS，第一个是微软的汇编器，第二个是另一个很有名的汇编器，他的文件后缀似乎一般是`.asm`，第三个是GNU的汇编器，使用的是`as`命令，后缀似乎一般是`.s`，据别人说NASM使用Intel语法，GAS使用AT&T语法，但是又说现在GAS也支持Intel语法了，还说其实NASM的语法也并不是标准的Intel语法，而是自己改造过的。所以这一切把我搞得很懵。不管了，走着看吧，我优先选择GAS

现在暂定的参考书是[汇编语言 第三版--王爽](https://book.douban.com/subject/25726019/)



### 寄存器

关于计算机的基本知识在计算机组成原理里面学过了，也可以看书的第一章了解一下，不表。

8086的寄存器有14个，分别是：

AX BX CX DX 四个通用寄存器，16位，分别可分为高八位，第八位，例如AH,AL



数据的尺寸有两种，分别是字节数据，即8位的byte，还有两个字节的word，也成字

~~~assembly
mov ax,18
mov ah,78
add ax,8
mov ax,bx
~~~

对于mov指令而言，它将第二个操作参数，送入第一个，对于add指令，加两个操作数，并将结果存入第一个

这里需要说明的是，两个操作数的位数应该是一致的，例如我们不应该`mov al,bx`，但是对于数字，只要不超出就好，但是例如add，如果结果超出，会直接去掉高位



CS,IP两个寄存器大概是很熟悉的，是用来控制指令的，这里涉及到了8086的寻址方式，它是16位的，也就是说用来寻址的寄存器都是16位的，但是地址总线宽度是20位，也就是说寻址空间是1M，所以采用了两个16位拼接形成20位的方式来寻址，其中一个叫做段地址，一个叫做偏移地址，段地址左移4位加上偏移地址就是真实地址，所以很容易想到由于偏移地址是最长16位，而不是4位，也就意味着一个地址实际上有多种组合方式，事实就是这样。

对于指令的寄存器来说就是这样，CS是段地址，IP是偏移地址。

这两个寄存器的内容当然可以修改，指令是`jmp 段地址:偏移地址`，这就可以将两个寄存器更改为想要的值

也可以单独修改IP，指令为：`jmp 寄存器`，例如`jmp ax`可以将IP修改为ax的值，要注意的还是保持位数一致

代码段的概念，指的是内存中的一段连续空间放的是代码，但是在CPU看来明显并不分什么代码和数据，要想让他成为代码，就是把CS，IP指向这一段就可以了

噢，还有一个指令执行完毕之后，IP是会只加的，自动加上这一段指令的长度，从而指向下一段指令



### 内存访问

内存的访问需要内存地址，内存地址同样使用段地址和偏移地址的结构，有一个DS寄存器，用来存储段地址，16位，mov命令可以用于从内存单元取数据，格式是:`mov 寄存器 [偏移]`，将会从DS中拿到段地址，在加上偏移地址，将对应的内存单元数据转存到寄存器中。设置DS寄存器硬件结构决定不能直接设置，只能将地址存入一个通用寄存器，再从寄存器转移到DS

注意一个内存单元8位

再注意，真实地址的构成依旧是段地址左移4位加偏移地址

调换寄存器和偏移的位置就可以实现存储

8086有16根数据线，所以是可以一次实现一个字的存取的，方法和上面没有区别，只要寄存器是16位的实现的就是字存取，8位就是单元存取



#### mov命令总结

mov命令的形式有以下几种：

~~~assembly
mov 寄存器，数据    ; mov ax,8H
mov 寄存器，寄存器  ; mov ax,bx
mov 寄存器，内存单元; mov ax,[0]
mov 内存单元，寄存器; mov [0],ax
mov 段寄存器，寄存器; mov ds,ax
~~~

sub,add命令与此类似，但是应该没有最后一种形式，这两个命令也是两个操作数，分别是用第一个操作数减第二个操作数，结果存入第一个操作数，和加

它们与内存单元做处理的时候也是根据另一个操作数决定去内存单元，还是取字

注意对于一个字而言，高地址存高8位，低地址存低8位



#### 数据段

前面提到了代码段的概念，数据段与之类似



### 栈

8086提供了栈，和对应的出入栈命令，push,pop，对栈的操作是以字为单位的

明显CPU需要知道栈在哪，栈顶在哪，这个与`CS:IP`颇为类似，栈是由`SS:SP`控制的，任何时刻`SS:SP`都指向栈顶，自动变更这两个寄存器的值是由CPU自动完成的

在执行pop和push的时候，CPU自动完成的是对SP的+-2的操作，而SS在和SP相加的时候做的是左移四位的操作，这意味着栈长度对应的地址长度4位，也即栈长16字节，8字，所以对栈的违规操作自然会超出栈的范围，CPU是不会管理这个的，用户要自己小心。

### 栈段

我们可以自行控制的方式实现栈段，也即扩大栈的长度



### 汇编程序

书上终于讲到汇编程序了，可是我十分怀疑按照他的写法，在GAS下是否可以运行

~~~assembly
assume cs:code

code segment
	mov ax,0123H
	mov bx,1456H
	add ax.bx
	add ax,ax
	
	mov ax,4c00H   ;返回
	int 21H        ;返回
code ends

end
~~~

解释一下这段代码，首先呢`code segment.....code ends`这就是一个代码段，名字叫做code，这是随便起的，segment和ends是关键词，标志着代码段的开始和结束

assume命令中`cs:code`就是将cs指向这个代码段的开始，从这里开始执行，end是代码的结束。

考虑执行的过程，明显处理机要总之现在的工作，然后执行我们的代码，结束再返回，所以存在一个返回现场的过程，对应的就是返回的那两行，至于为啥这样写，暂时未知



因为编译器也不一样，所以，我没执行这段程序，所以，编译链接自不必说



### [BX]与Loop

考虑`mov ax,[bx]`，我们很了解`mov ax,[0]`，对应的就容易理解了，只是意味着偏移存在bx里面而已

新命令inc bx代表把bx加1



