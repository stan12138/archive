## C++笔记

> 只是大概的记录一点要点 
>
> ---by stan

### 开发环境

我选择codeblockds作为开发环境，没有为什么，也没有对比，只是随便选的。

安装很简单，唯一需要的就是编译器，我们需要想办法搞到一个编译器，我弄到的好像叫mingw，然后你到codeblocks的编译器选项里面，选择GNU GCC，选择toolchain executables里面选择mingw的bin文件夹，然后在complier setting里面选择c++11即可，重启就ok了，应该吧，反正现在是这样。



呃，也许我应该尝试一些更加基本的东西。

使用文本编辑器完成代码，然后使用命令行进行编译

c++的编译器有很多，比较出名的是`icc,gcc,clang,vc++`

其中的icc指的是intel c++ compiler，是英特尔的编译器

gcc 是GNU Compiler Collection

而clang据很多人说要比gcc好，他也的确很受欢迎

vc++来自微软，就不说了。

gcc在windows上面要使用移植版本，比较出名的移植版本是MinGW，TDM-GCC，Cygwin

我这里用的就是第一个，我的水平还没有到达要选择编译器的程度，所以关于编译器的优劣就不做比较，只是知道一些基本知识就好。

如果我们想在任意文件夹的命令行下使用某个命令，例如python a.py这种，有两个要求，第一我们要有一个python.exe文件，第二我们必须把这个exe文件所在的目录加入到环境变量的path中

所以，为了使用命令行编译，我们需要把mingw的bin目录添加到path中

观察这个目录你会发现有巨多的exe文件我们应该使用哪一个呢？他们有个有什么区别呢？

准确的说，我不知道。但是建议使用g++，换句话说，当我们想编译一个cpp文件的时候，我们应该在该文件所在的目录下打开命令行，输入g++ -o name file.cpp

name指定了输出文件的名字，输出文件将是name.exe，file.cpp是我们要编译的文件的名字

运行直接输入name即可

差不多，暂时就是这样。



### 介绍

#### 输入与输出

c++并未定义输入输出语句，而是使用了一个标准库。

这里使用的是iostream库，这个库有两个基本类型，istream和ostream。还有四个IO对象，标准输入cin，是istream的对象，标准输出cout，ostream的对象。另有两个输出类型的：警告cerr，日志clog



如果要使用标准库，就必须include，这些名字在标准命名空间中，所以应该使用`std::cout`这样的名字来引用。

向cout和cin交互数据，应该使用输入输出运算符`<<和>>`，速记法尖朝谁说明要把数据给谁，最后应该使用`std::endl`保持数据刷新

`cout`是自带换行的，然后在cin中，空格和回车都是结束一次输入的符号，不同之处在于回车会让cin刷新，做下一步操作，而空格只会存储，然后被作为分隔符。



关于输入输出的重定向，书上说`exename infilename outfilename`就可以，但尝试之后都不行。网上给的方法都是要在源代码里面实现。

##### 关于不定数量的数据

如果想读入不定数量的数据，那么要使用循环读入的技术，但是我们如何终止呢？

对于普通的数据类型，例如正数，我大可输入一个字符，当类型对不上的时候就会被终止。

对于字符串类型该怎么办？我们要么在window上面使用`ctrl+c`强制终止，要么使用文件结束符：首先按下`ctrl+z`，然后回车即可终止。



##### main函数

改掉把主函数写成void的习惯，应该是int类型，正常结束我们应该返回0



### 变量与类型

我的划分是分为布尔，字符，整型，浮点型四类

-   布尔，`bool`
-   字符：
    -   `char`,8bit
    -   `wchar_t`,16bit
    -   `char16_t`,16bit
    -   `char32_t`,32bit
-   整型：
    -   `short`,16bit
    -   `int`,16bit
    -   `long`,32bit
    -   `long long`,64bit
-   浮点型：
    -   `float`,6位有效数字
    -   `double`,10位有效数字
    -   `long double`，10位有效数字

选用的时候，应该注意，虽然上表指定了尺寸，但是这是最小尺寸，选择数据类型的时候，如果数据是非负，应该选用无符号的；通常不用int，如果int太小，直接选long long;浮点数优先选择double

#### 类型转换

当混用有符号和无符号类型的时候，极易发生问题。不要这样做。

#### 字面值常量

八进制以0开头，十六进制以0x或0X开头

支持使用e的科学记数法

#### 类型限定

通过使用特定的前后缀，可以改变整型，浮点型，字符型字面值的默认类型

![类型限定](images/前缀.png)

这里要注意几点：

-   首先u8仅适用于字符串，其次，u8只有8bit，这个确实很奇怪，因为utf8并不是说只有8bit，它是一种传输标准，每次传输8bit，utf8实际上是变长编码
-   要记得，字符和字符串只有前缀，数字只有后缀。



#### 初始化技术

如果再加上默认初始化，那么应该说一共有5种形式的初始化技术。

-   默认初始化，对于内置类型，如果被定义在函数体之外，且未被初始化，将会触发默认初始化，即被初始化为0，但是函数体内的不回被默认初始化。
-   普通初始化方法，int a=0;
-   圆括号初始化，int a(0)，与普通初始化没有任何不同
-   列表初始化形式1，int a={1.23}
-   列表初始化形式2，int a{1.23}

列表初始化技术与普通的初始化的却别就在于，对于普通的初始化，如果赋值的类型不正确，会自动转换，但是列表初始化如果类型不符，将会警告，或者直接报错。

#### 声明

分离式编译与跨文件引用，如果我们要使用另一份文件里面的名字，那么一定要声明，而源文件要做定义。

声明与定义因此在跨文件时变得很不同，如果要声明，必须满足两个条件：

-   类型之前加`extern`关键字
-   不能赋初值

所以一个声明必须是这样的形式:`extern int i;`

#### 作用域

作用于的概念很广泛，每一个花括号就是一个作用域

### 引用

引用和指针都是复合类型，所以单独摘录

引用不是一个对象，引用只是起别名，引用的三个要求：

-   使用`&`
-   必须初始化
-   初始值必须是指定类型的对象

所以应该像这样`int a=3, &b = a;`



### 指针

指针的类型必须严格和指向的对象匹配，只有一种情况，a是一个指向int的int类型指针，那么指向a的指针也应该是int

##### 空指针

空指针可以直接赋值为`nullptr`或者0

也可以赋值NULL，但是要求必须包含`cstdlib`，因为它定义在这里，其实就是0



赋给指针的值除了0之外，不能是其他字面值，但可以是另一个指针，或者就是最普通的取址符

`void*指针`它是特殊类型的指针，它可以存储任何类型对象的地址，但是正因如此，不能对内容做任何访问，只能用于比较，或者作为函数的输入输出



不存在指向引用的指针，但是存在指针的引用，`int *&a`代表a是一个int型指针的引用

判断类型的最佳方法就是观察距离变量最近的修饰符，最近的影响力最大。



### const限定符

常量

只需要对一个变量加入const修饰符，就可以将其变为常量跨文件引用的常量必须在定义处和其他文件中都使用extern修饰符

####常量引用

对常量的引用简称常量引用，但是不能用于修改

我们可以考虑一下，常量引用，全称对常量的引用，引用要求必须初始化，所以我们应该将常量引用初始化为一个常量，但是事实上并非如此，有两种特殊情况：

-   只要表达式可以转化为引用类型，常量引用就可以使用它作为初始值，所以是可以绑定非常量的对象，字面值，甚至表达式的。从编译器角度来看，当你绑定一个非常量，或者类型都不太对的对象的时候，会首先执行一个类型转换并创建一个常量，然后将常量引用绑定其上。

不过说实话，我并不知道这样的意义何在，引用存在的意义是可以与原变量相关联，使二者变化同步（就是一个东西），但是常量是保持不变，同时又绑定到了一个初始化结束后就会被销毁的对象上面去，我不明白这是在折腾啥？

不过这里还是要注意一下，有点意思，对于int常量引用，你可以初始化一个double变量，会自动执行转化，但是对于单纯的引用而言，绝对不允许类型不一致。



这里必须声明一下，也许我懂得了一点常量引用的特殊之处了。如果我们给一个常量初始化为一个变量，那么事实上只是拷贝了数值过去。但是对于常量引用，如果初始化为一个变量，这里的常量只意味着我们无法通过这个常量修改她所引用的变量，但是我们完全可以直接修改变量，并且同时变化会映射到常量。

总而言之，对于普通的常量，绑定的是一块与其他对象无关的内存块，对于常量引用，绑定的是一个地址，自己不能修改地址内容，但是其他对象可以操作这一块地址。

#### 常量与指针

##### 指向常量的指针

我们可以直接让一个指针指向一个常量，那么这个指针将无法修改其指向的常量的值，但是我们可以让指向常量的指针重新指向其他对象，但是无一例外，他丧失了修改自己指向的对象的能力

##### 常量指针

`const int *p;`意味着这是一个指向int常量的指针，但是`int *const p;`却意味着这个指针是一个常量指针，换句话说他自己是一个常量，将丧失改变自己指向的地址的能力

那么常量指针意味着什么呢？我们可以给他初始化一个普通对象的地址，也可以是一个常量的地址，常量指针意味着地址不能再改，常量则意味着这块地址的内容不能改，所以对于普通的地址，我们依旧可以通过常量指针修改内容。



于是你会发现，事情似乎变得复杂了起来，于是我们有必要引入顶层const和底层const的概念

#### 顶层const和底层const

对于一个常量，我们不能让普通的指针指向它，必须是一个指向常量的指针。

指针自己就是一个对象，但是又可以指向另一个对象，于是就必须要辨别自己是常量，还是指向的对象是常量。

指针自己是常量称为顶层const，指向的对象是常量称为底层const

推广开来，自己是常量就是顶层const，自己引用的或指向的是const就是底层const



这里可以总结一下，一个常量意味着这块地址的内容不能改变，我们为常量初始化一个变量发生的只是拷贝；但是我们可以使用常量引用，让常量改变拷贝的行为，去引用一个变量，这导致的结果是常量引用不能直接修改变量，但是它所引用的那块地址的内容却可以改变，因为引用不是对象，所以不存在自己是常量的引用；指向常量的指针，意味着自己不能修改自己指向的地址的内容，但是却可以修改自己指向的地址，相当于阉割版的指针；常量指针意味着自己被指向了固定的地址，但是只要自己指向的对象不是常量，就可以修改地址内的内容，相当于特异化的指针。所以常量是顶层常量，引用只有底层的，常量指针是顶层的，指向常量的指针是底层的。

还要总结一下赋值情况：

对于普通的引用，赋值的时候要求类型必须严格对应

对于常量而言，则并不在意值是不是常量，所以常量引用也并不要求值是常量，指向常量的指针也完全可以指向普通地址，而常量指针则只是在说明自己是常量，并不在意地址是不是一个常量的地址。

#### 常量表达式

常量表达式指值不会改变，并且只是通过编译就可以知道值的表达式。

常量表达式的认定是比较困难，几乎不可能的事情。

c++11允许将变量声明为`constexpr`类型来确认它是常量表达式

字面值常量是常量表达式，指针和引用也可以通过`constexpr`来指定为常量表达式，但这种情况下对他们的初始值要求很严格，指针必须是`nullptr`或者0

总之很烦，暂时似乎也没用



### 类型的处理

#### 别名

为类型取别名有两种方法，一是传统的typedef，如下：

`typedef originname shortname;`

第二种是用`using`:

`using shortname = originname;`

#### auto说明符

给出初值，auto会自动判定类型。

这里要注意，当初始值是引用的时候，判定的类型是被引用对象的类型

auto还会忽略顶层const，保留底层const



#### 类型指示符decltype

decltype会忠实的还原所有的类型，包括引用和常量

指针的解引用得到的是引用

当使用两个圆括号时得到的永远是引用



### 自定义数据结构

这里暂时使用struct定义类，但是这里的struct和c里面的稍微有一些不同，见下面的例子：

~~~c++
struct test
{
    std::string name="stan";
    int years = 10;
};
test first;
~~~



一般而言，我们倾向于将类定义在其他文件中，这个文件是头文件。

首先，我们要把头文件的名字保持与类名一致，后缀为`.h`

因为在头文件里面我们需要包含其他的头文件，当引用的时候又会再包含一次，所以可能会引起重复包含的问题，他也没有python什么的控制导出的名字，所以，为了解决这一问题，需要使用预处理器

预处理器是一种语法，基本上就是这个样子：

~~~h
#ifndef STAN_H
#define STAN_H
#include<string>
struct Stan
{
    std::string name="stan";
    int years = 10;
};
#endif
~~~

据网上的说明，为了防止名字重复，保护性措施是将名字全部大写，并把`.`替换为`_`，更有甚者甚至会在两边都加上`_`，我并不清楚预处理器是怎么完成转换的，保守一点，我只是大写和替换点号

上面就是`Stan.h`文件的全部内容。

注意一下，当我们要包含自行定义的头文件的时候，应该使用`""`，并携带后缀

然后，头文件无需编译什么的



### 命名空间的问题

为了不再在每个使用cout的地方写`std::cout`，我们可以使用`using std::cout;`，诸如此，注意每次只能写一个

注意，最好不要在头文件中使用using





### 字符串

string

初始化可以使用一种类似圆括号初始化的方式，传入两个参数，第一个是n，第二个是一个字符，可以产生由n个相同字符连缀而成的初值

其他的初始化方式无本质差别，但表达上还是有些区别的，我觉得也没有太多的必要去费心记忆

#### 读写

自I/O中读写字符串并没有什么特别之处，这里只说明一个之前未曾提及的一次读取一行，使用getline()函数，当getline把得到的一行存入string的时候，会删掉最后的换行符



#### 尺寸与索引

string类型的empty方法和size方法分别提供空判断和返回尺寸

当我们想逐个处理string中的每个字符的时候，我们可以使用两种方式，范围for语句，或者下标随机访问

~~~c++
for(auto i : somestring)
{
    do_domething;
}
~~~

注意，如果我们想要修改其中的字符的话，我们应该使用引用

~~~c++
for(auto &i : somestring)
{
    do_domething;
}
~~~

当使用下标的时候，一切都如所想，只是下标的数据类型有点恶心，他的类型是`string::size_type`，所以，我们可能会习惯这样写循环变量：

`decltype(s.size()) i = 0;`

当然也可以直接声明：`string::size_type n;`

#### 操作

string重载了一系列运算符，因此可以使用`== >= <= > <`等

同时也支持相加和复合的`+=`

支持和字符或字符串字面值的相加，但是不支持其他类型







### 迭代器

迭代器提供了一种比前述的索引和范围for更方便的成员访问方式。

一般而言，标准库容器都支持迭代器，字符串并不是容器，但是他也对迭代器做了支持。

#### 如何使用

支持迭代器的容器或者对象都有两个方法，分别是begin()和end()，他们都会返回一个迭代器类型成员，呃，并不太确切，事实上我们不太容易知道他的准确类型，也完全没有必要知道。

但是返回的对象在行为表现上颇类似于指针，虽然他并不是指针。

在使用的时候我们会使用`auto a=s.begin();`拿到第一个元素，s.end()指向的是最后一个元素的下一个位置，所以对于循环而言，进行下去的条件是`a != s.end()`

返回的迭代器对象支持`++ --`操作，从而实现前后移动，也支持`== !=`这样的逻辑运算

与指针一样，我们想获取元素的引用，从而实现对元素的原地改变通过的是解引用操作`*a = 10`，例如这样

如果元素是一个类，那么我们想访问类的成员的时候，也和指针一样使用`a->getname()`诸如此类的操作，繁琐的形式就是`(*a).getname();`

额外的，为了实现非连续的跳转，还支持与整数的加减，乃至除法操作。与之匹配的还有`> < >= <=`等逻辑操作



差不多就是这样



### 数组

数组其实和之前并没有十分巨大的区别，定义的时候必须指定类型和长度，按照书上说长度必须是常量表达式，并且会进行默认初始化。

但是这里要注意几个问题，首先，长度必须是常量表达式，那么即使是一个普通的变量都是不行的，但是这是对于全局变量而言的，也即位于任何结构之外的，并且回忆一下，默认初始化也要求位于结构之外，在函数内部的不会进行默认初始化。

如果我们把数组定义在函数内部，例如main函数，那么我们完全可以让长度不是常量表达式，可以是输入的变量，但是这里也不会进行默认初始化。

#### 初始化

数组进行初始化的时候使用的都是列表初始化，除非是字符数组的初始化（可以使用字符串），这两种情形下都可以分成不同的形式，第一种如果指定了数组的长度，那么列表不能超过数组的长度，第二种，还可以只给出初始化列表，不指定长度，这种情况下会自动确定长度。

对于巨长的数组，如果不使用默认初始化，也可以使用`int a[10] = {0}`这样的形式完成初始化

#### 复杂的声明

对于数组，自然是可以定义指针和引用的，同时也可以定义存储指针的数组

对于存储指针的数组，我们这样定义`int *p[10];`，很简单易懂

指向一维数组的指针，我们并不需要做什么特别处理，元素是什么类型就定义一个什么类型的指针就好，`int a[10], *p=&a;`

我觉得事实上，并没有多少的必要定义数组的引用

但是当出现多维数组的时候，我们该怎么定义指针呢？例如`int a[2][10]`，a的每一个元素都是一个一维数组，所以我们必须要定义一个指向一维数组的指针，定义的方式应该是`int (*ptr) [10]=&a[0];`

所以对于最后一种的解读可能会有点让人迷惑，这里书中总结了最好的方式应该是从名字开始由内向外读

#### 注意

数组是无法直接复制，无法比较的

#### 访问

数组的访问可以使用普通的下标，也可以使用范围for，还可以使用指针，当使用指针的时候，c++还提供了两个辅助函数，begin()和end()返回指针，分别指向第一个元素，和最后一个元素的下一个位置。注意这两个要通过std获得。

特别的，那是用指针的时候还支持一种简洁的表达：`*(p+2)`等价于`p[2]`

~~~c++
#include<iostream>
#include<string>
#include "Stan.h"

using std::cin;
using std::cout;
using std::endl;
using std::string;
using std::begin;
using std::end;


int main()
{
    int a[10];
    for(int i=0;i<10;i++) cout<< a[i] <<endl;

    for(auto i : a) cout<< i <<endl;

    int *p = begin(a);
    int *last = end(a);
    for(p;p!=last;p++) cout<< *p <<endl;

    int *p1 = a;
    for(int i=0;i<10;i++) cout<< p1[i] <<endl;

}
~~~



#### 多维数组

多维数组，初始化的时候完全可以按照多维的形式排列初始化列表，也可以直接排成一行

索引的时候可以直接使用下标，也可以使用范围for和指针

但此时，后二者会比较麻烦一点

首先对于范围for，假设数组是二维的，那么for肯定是双重的，如果想要原地修改必须是引用，但是即便不想修改，第一层也必须要设定为引用，因为不这样做系统就会把第一个认定为是一个地址而已，第二重就无法进行下去了。

当时用指针的时候，更为麻烦，我们必须定义数组指针，但是如果只是为了遍历的话，我们就可以借助begin和end，直接设置为auto

~~~c++
    int c[2][5] = {0};
    for(auto p2= begin(c);p2!=end(c);p2++)
    {
        for(auto p3=begin(*p2);p3!=end(*p2);p3++)
            cout << *p3 << endl;
    }
~~~







### vector类型

现在我们可以来看一下什么是vector

vector可以被看作是一个可变长度的数组，但是它同样要求元素类型一致。

首先必须导入vector头文件，vector还位于标准空间中

`vector<int> a;`，诸如此，指定类型。

支持直接拷贝，也支持列表初始化，还支持圆括号形式的参数，一个参数代表开多大的空间，两个参数代表重复n次第二个值。

但是很特别的，虽然一般情况下，列表初始化就是值，但是当类型不匹配的时候，例如string类型的vector，但是却给了一个`{3},{3,"hello"}`这样形式的列表的时候，他们将会变得和圆括号效果一致。



#### 添加元素

既然是变长的，那么我们是可以通过`a.push_back(b)`这样的方法，将b添加到a的尾部

绝对不可以使用下标来增长，增长只有这么一种方式

#### 索引与访问

vector支持范围for，支持迭代器，也支持下标

当时用下标的时候，提供了两个辅助方法，empty()和size()，我们可以将索引定义为int，这样可以工作，但事实上，它和string的索引一样，都是`size_type`类型的，严格来说，至少应该使用unsigned，但是坚持用int的话，也是没问题的。



### 表达式

表达式这一部分，我觉得大多数都是常识，所以基本可以跳过

只说一下sizeof()可以求字节数

然后混合解引用和自增,`*p++`这个的意思是先解引用，返回结果，然后再完成自己的自增运算

还有强制类型转换，使用`cast-name<type>(expression);`

这个式子的意义是，利用某种形式的转换，将expression的类型转换为type类型

`cast-name`指定了形式，主要有四种:`static_cast,dynamic_cast,const_cast,reinterpret_cast`

其中含义等我用的上的时候再说吧。





### 语句











