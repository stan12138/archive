## C++笔记

> 只是大概的记录一点要点 
>
> ---by stan

### 开发环境

我选择codeblockds作为开发环境，没有为什么，也没有对比，只是随便选的。

安装很简单，唯一需要的就是编译器，我们需要想办法搞到一个编译器，我弄到的好像叫mingw，然后你到codeblocks的编译器选项里面，选择GNU GCC，选择toolchain executables里面选择mingw的bin文件夹，然后在complier setting里面选择c++11即可，重启就ok了，应该吧，反正现在是这样。



呃，也许我应该尝试一些更加基本的东西。

使用文本编辑器完成代码，然后使用命令行进行编译

c++的编译器有很多，比较出名的是`icc,gcc,clang,vc++`

其中的icc指的是intel c++ compiler，是英特尔的编译器

gcc 是GNU Compiler Collection

而clang据很多人说要比gcc好，他也的确很受欢迎

vc++来自微软，就不说了。

gcc在windows上面要使用移植版本，比较出名的移植版本是MinGW，TDM-GCC，Cygwin

我这里用的就是第一个，我的水平还没有到达要选择编译器的程度，所以关于编译器的优劣就不做比较，只是知道一些基本知识就好。

如果我们想在任意文件夹的命令行下使用某个命令，例如python a.py这种，有两个要求，第一我们要有一个python.exe文件，第二我们必须把这个exe文件所在的目录加入到环境变量的path中

所以，为了使用命令行编译，我们需要把mingw的bin目录添加到path中

观察这个目录你会发现有巨多的exe文件我们应该使用哪一个呢？他们有个有什么区别呢？

准确的说，我不知道。但是建议使用g++，换句话说，当我们想编译一个cpp文件的时候，我们应该在该文件所在的目录下打开命令行，输入g++ -o name file.cpp

name指定了输出文件的名字，输出文件将是name.exe，file.cpp是我们要编译的文件的名字

运行直接输入name即可

差不多，暂时就是这样。



### 介绍

#### 输入与输出

c++并未定义输入输出语句，而是使用了一个标准库。

这里使用的是iostream库，这个库有两个基本类型，istream和ostream。还有四个IO对象，标准输入cin，是istream的对象，标准输出cout，ostream的对象。另有两个输出类型的：警告cerr，日志clog



如果要使用标准库，就必须include，这些名字在标准命名空间中，所以应该使用`std::cout`这样的名字来引用。

向cout和cin交互数据，应该使用输入输出运算符`<<和>>`，速记法尖朝谁说明要把数据给谁，最后应该使用`std::endl`保持数据刷新

`cout`是自带换行的，然后在cin中，空格和回车都是结束一次输入的符号，不同之处在于回车会让cin刷新，做下一步操作，而空格只会存储，然后被作为分隔符。



关于输入输出的重定向，书上说`exename infilename outfilename`就可以，但尝试之后都不行。网上给的方法都是要在源代码里面实现。

##### 关于不定数量的数据

如果想读入不定数量的数据，那么要使用循环读入的技术，但是我们如何终止呢？

对于普通的数据类型，例如正数，我大可输入一个字符，当类型对不上的时候就会被终止。

对于字符串类型该怎么办？我们要么在window上面使用`ctrl+c`强制终止，要么使用文件结束符：首先按下`ctrl+z`，然后回车即可终止。



##### main函数

改掉把主函数写成void的习惯，应该是int类型，正常结束我们应该返回0



### 变量与类型

我的划分是分为布尔，字符，整型，浮点型四类

-   布尔，`bool`
-   字符：
    -   `char`,8bit
    -   `wchar_t`,16bit
    -   `char16_t`,16bit
    -   `char32_t`,32bit
-   整型：
    -   `short`,16bit
    -   `int`,16bit
    -   `long`,32bit
    -   `long long`,64bit
-   浮点型：
    -   `float`,6位有效数字
    -   `double`,10位有效数字
    -   `long double`，10位有效数字

选用的时候，应该注意，虽然上表指定了尺寸，但是这是最小尺寸，选择数据类型的时候，如果数据是非负，应该选用无符号的；通常不用int，如果int太小，直接选long long;浮点数优先选择double

#### 类型转换

当混用有符号和无符号类型的时候，极易发生问题。不要这样做。

#### 字面值常量

八进制以0开头，十六进制以0x或0X开头

支持使用e的科学记数法

#### 类型限定

通过使用特定的前后缀，可以改变整型，浮点型，字符型字面值的默认类型

![类型限定](images/前缀.png)

这里要注意几点：

-   首先u8仅适用于字符串，其次，u8只有8bit，这个确实很奇怪，因为utf8并不是说只有8bit，它是一种传输标准，每次传输8bit，utf8实际上是变长编码
-   要记得，字符和字符串只有前缀，数字只有后缀。



#### 初始化技术

如果再加上默认初始化，那么应该说一共有5种形式的初始化技术。

-   默认初始化，对于内置类型，如果被定义在函数体之外，且未被初始化，将会触发默认初始化，即被初始化为0，但是函数体内的不回被默认初始化。
-   普通初始化方法，int a=0;
-   圆括号初始化，int a(0)，与普通初始化没有任何不同
-   列表初始化形式1，int a={1.23}
-   列表初始化形式2，int a{1.23}

列表初始化技术与普通的初始化的却别就在于，对于普通的初始化，如果赋值的类型不正确，会自动转换，但是列表初始化如果类型不符，将会警告，或者直接报错。

#### 声明

分离式编译与跨文件引用，如果我们要使用另一份文件里面的名字，那么一定要声明，而源文件要做定义。

声明与定义因此在跨文件时变得很不同，如果要声明，必须满足两个条件：

-   类型之前加`extern`关键字
-   不能赋初值

所以一个声明必须是这样的形式:`extern int i;`

#### 作用域

作用于的概念很广泛，每一个花括号就是一个作用域

### 引用

引用和指针都是复合类型，所以单独摘录

引用不是一个对象，引用只是起别名，引用的三个要求：

-   使用`&`
-   必须初始化
-   初始值必须是指定类型的对象

所以应该像这样`int a=3, &b = a;`



### 指针

指针的类型必须严格和指向的对象匹配，只有一种情况，a是一个指向int的int类型指针，那么指向a的指针也应该是int

##### 空指针

空指针可以直接赋值为`nullptr`或者0

也可以赋值NULL，但是要求必须包含`cstdlib`，因为它定义在这里，其实就是0



赋给指针的值除了0之外，不能是其他字面值，但可以是另一个指针，或者就是最普通的取址符

`void*指针`它是特殊类型的指针，它可以存储任何类型对象的地址，但是正因如此，不能对内容做任何访问，只能用于比较，或者作为函数的输入输出



不存在指向引用的指针，但是存在指针的引用，`int *&a`代表a是一个int型指针的引用

判断类型的最佳方法就是观察距离变量最近的修饰符，最近的影响力最大。



### const限定符

常量

只需要对一个变量加入const修饰符，就可以将其变为常量跨文件引用的常量必须在定义处和其他文件中都使用extern修饰符

####常量引用

对常量的引用简称常量引用，但是不能用于修改

我们可以考虑一下，常量引用，全称对常量的引用，引用要求必须初始化，所以我们应该将常量引用初始化为一个常量，但是事实上并非如此，有两种特殊情况：

-   只要表达式可以转化为引用类型，常量引用就可以使用它作为初始值，所以是可以绑定非常量的对象，字面值，甚至表达式的。从编译器角度来看，当你绑定一个非常量，或者类型都不太对的对象的时候，会首先执行一个类型转换并创建一个常量，然后将常量引用绑定其上。

不过说实话，我并不知道这样的意义何在，引用存在的意义是可以与原变量相关联，使二者变化同步（就是一个东西），但是常量是保持不变，同时又绑定到了一个初始化结束后就会被销毁的对象上面去，我不明白这是在折腾啥？

不过这里还是要注意一下，有点意思，对于int常量引用，你可以初始化一个double变量，会自动执行转化，但是对于单纯的引用而言，绝对不允许类型不一致。



这里必须声明一下，也许我懂得了一点常量引用的特殊之处了。如果我们给一个常量初始化为一个变量，那么事实上只是拷贝了数值过去。但是对于常量引用，如果初始化为一个变量，这里的常量只意味着我们无法通过这个常量修改她所引用的变量，但是我们完全可以直接修改变量，并且同时变化会映射到常量。

总而言之，对于普通的常量，绑定的是一块与其他对象无关的内存块，对于常量引用，绑定的是一个地址，自己不能修改地址内容，但是其他对象可以操作这一块地址。

#### 常量与指针

##### 指向常量的指针

我们可以直接让一个指针指向一个常量，那么这个指针将无法修改其指向的常量的值，但是我们可以让指向常量的指针重新指向其他对象，但是无一例外，他丧失了修改自己指向的对象的能力

##### 常量指针

`const int *p;`意味着这是一个指向int常量的指针，但是`int *const p;`却意味着这个指针是一个常量指针，换句话说他自己是一个常量，将丧失改变自己指向的地址的能力

那么常量指针意味着什么呢？我们可以给他初始化一个普通对象的地址，也可以是一个常量的地址，常量指针意味着地址不能再改，常量则意味着这块地址的内容不能改，所以对于普通的地址，我们依旧可以通过常量指针修改内容。



于是你会发现，事情似乎变得复杂了起来，于是我们有必要引入顶层const和底层const的概念

#### 顶层const和底层const

对于一个常量，我们不能让普通的指针指向它，必须是一个指向常量的指针。

指针自己就是一个对象，但是又可以指向另一个对象，于是就必须要辨别自己是常量，还是指向的对象是常量。

指针自己是常量称为顶层const，指向的对象是常量称为底层const

推广开来，自己是常量就是顶层const，自己引用的或指向的是const就是底层const



这里可以总结一下，一个常量意味着这块地址的内容不能改变，我们为常量初始化一个变量发生的只是拷贝；但是我们可以使用常量引用，让常量改变拷贝的行为，去引用一个变量，这导致的结果是常量引用不能直接修改变量，但是它所引用的那块地址的内容却可以改变，因为引用不是对象，所以不存在自己是常量的引用；指向常量的指针，意味着自己不能修改自己指向的地址的内容，但是却可以修改自己指向的地址，相当于阉割版的指针；常量指针意味着自己被指向了固定的地址，但是只要自己指向的对象不是常量，就可以修改地址内的内容，相当于特异化的指针。所以常量是顶层常量，引用只有底层的，常量指针是顶层的，指向常量的指针是底层的。

还要总结一下赋值情况：

对于普通的引用，赋值的时候要求类型必须严格对应

对于常量而言，则并不在意值是不是常量，所以常量引用也并不要求值是常量，指向常量的指针也完全可以指向普通地址，而常量指针则只是在说明自己是常量，并不在意地址是不是一个常量的地址。

#### 常量表达式

常量表达式指值不会改变，并且只是通过编译就可以知道值的表达式。

常量表达式的认定是比较困难，几乎不可能的事情。

c++11允许将变量声明为`constexpr`类型来确认它是常量表达式

字面值常量是常量表达式，指针和引用也可以通过`constexpr`来指定为常量表达式，但这种情况下对他们的初始值要求很严格，指针必须是`nullptr`或者0

总之很烦，暂时似乎也没用



### 类型的处理

#### 别名

为类型取别名有两种方法，一是传统的typedef，如下：

`typedef originname shortname;`

第二种是用`using`:

`using shortname = originname;`

#### auto说明符

给出初值，auto会自动判定类型。

这里要注意，当初始值是引用的时候，判定的类型是被引用对象的类型

auto还会忽略顶层const，保留底层const



#### 类型指示符decltype

decltype会忠实的还原所有的类型，包括引用和常量

指针的解引用得到的是引用

当使用两个圆括号时得到的永远是引用



### 自定义数据结构

这里暂时使用struct定义类，但是这里的struct和c里面的稍微有一些不同，见下面的例子：

~~~c++
struct test
{
    std::string name="stan";
    int years = 10;
};
test first;
~~~



一般而言，我们倾向于将类定义在其他文件中，这个文件是头文件。

首先，我们要把头文件的名字保持与类名一致，后缀为`.h`

因为在头文件里面我们需要包含其他的头文件，当引用的时候又会再包含一次，所以可能会引起重复包含的问题，他也没有python什么的控制导出的名字，所以，为了解决这一问题，需要使用预处理器

预处理器是一种语法，基本上就是这个样子：

~~~h
#ifndef STAN_H
#define STAN_H
#include<string>
struct Stan
{
    std::string name="stan";
    int years = 10;
};
#endif
~~~

据网上的说明，为了防止名字重复，保护性措施是将名字全部大写，并把`.`替换为`_`，更有甚者甚至会在两边都加上`_`，我并不清楚预处理器是怎么完成转换的，保守一点，我只是大写和替换点号

上面就是`Stan.h`文件的全部内容。

注意一下，当我们要包含自行定义的头文件的时候，应该使用`""`，并携带后缀

然后，头文件无需编译什么的



### 命名空间的问题

为了不再在每个使用cout的地方写`std::cout`，我们可以使用`using std::cout;`，诸如此，注意每次只能写一个

注意，最好不要在头文件中使用using





### 字符串

string

初始化可以使用一种类似圆括号初始化的方式，传入两个参数，第一个是n，第二个是一个字符，可以产生由n个相同字符连缀而成的初值

其他的初始化方式无本质差别，但表达上还是有些区别的，我觉得也没有太多的必要去费心记忆

#### 读写

自I/O中读写字符串并没有什么特别之处，这里只说明一个之前未曾提及的一次读取一行，使用getline()函数，当getline把得到的一行存入string的时候，会删掉最后的换行符



#### 尺寸与索引

string类型的empty方法和size方法分别提供空判断和返回尺寸

当我们想逐个处理string中的每个字符的时候，我们可以使用两种方式，范围for语句，或者下标随机访问

~~~c++
for(auto i : somestring)
{
    do_domething;
}
~~~

注意，如果我们想要修改其中的字符的话，我们应该使用引用

~~~c++
for(auto &i : somestring)
{
    do_domething;
}
~~~

当使用下标的时候，一切都如所想，只是下标的数据类型有点恶心，他的类型是`string::size_type`，所以，我们可能会习惯这样写循环变量：

`decltype(s.size()) i = 0;`

当然也可以直接声明：`string::size_type n;`

#### 操作

string重载了一系列运算符，因此可以使用`== >= <= > <`等

同时也支持相加和复合的`+=`

支持和字符或字符串字面值的相加，但是不支持其他类型



### vector类型

vector位于vector头文件中，名字处于标准命名空间

呃，这似乎是类模板？感觉也许可以先放在一边的吧。、



### 迭代器





