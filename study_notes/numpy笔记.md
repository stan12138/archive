##### 图片
array(open('test,jpg')),可以将图片转换为numpy的array,使用Image.fromarray(arrray)可以将array转换为Image对象，如a=fromarray(b),a.save('new.jpg')即可将其保存为JPG图像

##### 插值
numpy的线性插值函数interp很有用，用法interp(x,xp,fp),xp,fp相当于一组x,y，直观一点说，相当于会根据xp,fp画出一个曲线，点与点之间以直线连接，x相当于一组给定的横坐标，这个函数会根据已经画出来的曲线，找出这一组x对应的纵坐标值。所以说在灰度值映射的时候，先根据已知函数计算出来把0-255映射给一个新的范围fp,此时，将xp设置为range(256),将已经扁平化的图像的一维数组作为x,传入interp即可

##### 超出范围的uint8
再次说明，numpy中的uint8()的转换是存在缺陷的，例如uint8(-1)=255,uint8(256)=0之类



### 关于矩阵的操作

首先，你必须把数据的类型搞对，对于很多操作，用脚想都知道int是不够的，然后float32和float64，但是当你将一个array声明为前者，输出时会标明float32，但是我看到后者并没有显示，不用过于担心，没问题的

然后，当我们在进行求逆的操作的时候，使用的是`numpy.linalg.inv`，只要你的数据类型正确，求出的结果绝对不会有任何问题，但是，注意矩阵的秩，一定要满秩，检查秩使用`numpy.linalg.matrix_rank()`

就这些

### 运算速度

numpy的运算速度比较快，但是绝对要注意，不要在计算的过程中错误的使用python原生的缓慢的数学运算，例如sum，或者abs等，条件允许的时候，尤其是进行数组的操作或者矩阵的操作的时候，应该使用numpy的运算。



### 广播与运算

在numpy和pandas中，很多计算方法都有axis参数，代表着沿轴计算。`axis=0~n`代表数组的第1到n-1个索引，沿某个轴计算，就代表去掉某个索引

所以，如果一个数组的shape是`(2,3,4,5)`，那么sum(a,axis=2)结果的shape将是`(2,3,5)`

#### 广播原则

如果我们想直接利用广播机制，那么我们必须了解广播的原则：

1.  系统会检查输入数组的shape，如果长度不一致，则通过在shape较短的数组的shape前面添加1来补充，直至shape一致。例如a的shape是`(4,3)`，而b的shape是`(5,)`，那么b的shape将会被调整为`(1,5)`
2.  确定输出数组的shape，每个值将是输入数组同一位置上的最大值，所以结果c的shape将是`(4,5)`
3.  确认可计算与否，检查每一个输入数组和输出数组在相同的shape位置上的值是否一致，如果均一致，或者输入的该位置是1，则可以计算，考虑shape的第二个位置，a是3，b是5，c是5，b与c一致，但是a却不一致，并且也不是1，那么该计算无法完成
4.  开始进行计算。如果两个输入的某一个维度数值一致，例如都是4行，但是a的第二个维度是3，b的第二个维度是1，那么结果的每一个第二个维度都将使用b的第一个第二维度进行计算，这个很费解，很绕口，拿这个来说就是结果的每一列都将利用b的第一列重复计算得到。

下面说回如何利用这个特点进行计算上面，如果我们想控制广播，那么我们实际上是控制了自动化的第一原则，按照我们的喜好进行定制。

考虑一个例子，我们有一个复杂的直方图统计，三变量的，我们有p，p12，p23，其中第一个是三个维度同时考虑的情况下得到的直方图频数统计，即落在每一个三维立方体内的颗粒数目，第二三个分别是落在12唯独组成的格子里的颗粒数目和23维度的，我们想计算`p/(p12*p23)`，那么明显除了手动利用for循环控制之外，我们另一个选择就是使用广播机制，但明显，我们必须做出控制，否则系统会自动为p12和p23都补充第一个维度，那么结果必然不对，于是就引出了定制化广播机制，诀窍就在于reshape，我们利用reshape主动控制，在我们想增加的地方设置维度为1，例如p12和p23都是`(2,2)`，那么我们的定制将是`p12 = p12.reshape(2,2,1)`，`p23 = p23.reshape(1,2,2)`，这样我们就会得到我们想要的结果

总之不需要太多的过脑子，例如a是3乘3的，b只有3个元素，如果我们想让a的每一行都乘上b，那么只需要`b = b.reshape(1,3)`，如果想要每一列，那么`b = b.reshape(3,1)`

总而言之，只要理论上可以完成计算，那么就可以通过reshape让计算以任何我们想要的方式完成