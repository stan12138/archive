##多线程
> -- by stan

---


###threading
推荐使用threading模块  
将一个线程设置为守护线程意味着这个线程是不重要的，整个python在所有的非守护线程推出之后就会退出。  

	threading.Thread(group=None,target=None,name=None,args=(),kwargs={},verbose=None,daemon=None)

这是一个Thread类，这就是一个线程类  

属性：name,ident,daemon
方法：start(),开始执行这个线程
     run(),定义线程功能的方法
	 join(timeout=None),直至线程终止前一直挂起，除非给出的时间到达
	 

对象实例化的时候传入的target是目标函数，args是函数的参数，返回值是一个线程实例，线程并不会立即开始执行，直至调用start()方法，

如果必须要等待线程完成，则需要调用join()方法  

###锁
threading模块提供了锁对象，Lock  

	lock = Lock()
	lock.acquire()
	lock.release()

锁对象有acquire方法和release方法，前者是锁定，后者是释放锁  


###信号量
threading模块提供了两种信号量类Semaphore和BoundedSemaphore。  

BoundedSemaphore实例化的时候要提供一个最大值，其资源总数永远不会超过最大值，信号量同样使用release方法增加一个资源，acquire方法获取一个资源  

记得必须使用锁来保证对于信号量的互斥操作


###queue对象
queue适用于多生产者，多消费者的任务，当多线程编程中信息必须安全的更改时，queue很有用。  
queue提供了三种类型的队列，FIFO,LIFO，Priority queue。很明显的吧，分别是先进先出，栈和优先级队列。  
这三者分别是三个类

	queue.Queue(maxsize=0)           FIFO
	queue.LifoQueue(maxsize=0)       LIFO
	queue.PriorityQueue(maxsize=0)   priority queue  

另外还有两个异常，`queue.Empty,queue.Full`，当Queue是空的同时非阻塞的get()唤起时，会引发前者，同样，当队列满的时候又唤起put方法时，就会引发后者  

上述的Queue指的是所有三种类型的队列  
同时这三种队列都有相同的一套方法  

- qsize(),这个方法会返回队列的近似尺寸，但是大于零不保证get()不会阻塞，小于零也不保证put()不会阻塞。这你妹的有啥用呢？

- empty(),当队列是空的的时候，返回值为True，但是它和下面的full方法一样，都不能保证进行get或put方法时不会阻塞  

- full()

- put(item,block=True,timeout=None)，把item放进队列，

###再叙Thread

关于一个线程，一般使用两个方式，要么直接实例化一个类，把要执行的函数以参数的形式传递进去，要么新建一个类，继承threading.Thread，对于一个新建的类，我们需要重写的方法只有两个，一个是__init__,另一个就是run，对于一个线程而言，当我们调用它的start()方法后，它就会开始以某些方式调用自己的run方法，所以本质上，run就是一个线程的主函数，当run执行完毕之后，线程就终结了。另外必须要注意的就是，如果将线程设置为守护线程，则当主线程结束是，不必等待该线程也结束，就会直接结束整个程序，还有一个join方法，如果线程A中调用了线程B的join方法，那么如果B不结束，线程A就会一直阻塞，无法结束。  
呃，join方法还是需要详细解释，如果线程A的程序中某一段写了B.join()，那么A会被阻塞在这个位置，直至B执行结束，A才会继续向下执行。  
所以可以说，对于最最基本的多线程的使用，为了让线程不在主线程结束的时候也结束，那么既可以将线程设置为非守护线程，也可以调用一下join方法。  


