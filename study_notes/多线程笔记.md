## 多线程
> -- by stan

### threading
推荐使用threading模块 
将一个线程设置为守护线程意味着这个线程是不重要的，整个python在所有的非守护线程推出之后就会退出。 
`threading.Thread(group=None,target=None,name=None,args=(),kwargs={},verbose=None,daemon=None)`

这是一个Thread类，这就是一个线程类 

属性：name,ident,daemon
方法：
- start(),开始执行这个线程
- run(),定义线程功能的方法
- join(timeout=None),直至线程终止前一直挂起，除非给出的时间到达

对象实例化的时候传入的target是目标函数，args是函数的参数，返回值是一个线程实例，线程并不会立即开始执行，直至调用start()方法，

如果必须要等待线程完成，则需要调用join()方法 

### 锁
threading模块提供了锁对象，Lock 
~~~python
lock = Lock()
lock.acquire()
lock.release()
~~~
锁对象有acquire方法和release方法，前者是锁定，后者是释放锁 

### 信号量

threading模块提供了两种信号量类Semaphore和BoundedSemaphore。

BoundedSemaphore实例化的时候要提供一个最大值，其资源总数永远不会超过最大值，信号量同样使用release方法增加一个资源，acquire方法获取一个资源

记得必须使用锁来保证对于信号量的互斥操作

### queue对象

queue适用于多生产者，多消费者的任务，当多线程编程中信息必须安全的更改时，queue很有用。
queue提供了三种类型的队列，FIFO,LIFO，Priority queue。很明显的吧，分别是先进先出，栈和优先级队列。
这三者分别是三个类

~~~python
queue.Queue(maxsize=0)           FIFO
queue.LifoQueue(maxsize=0)       LIFO
queue.PriorityQueue(maxsize=0)   priority queue  
~~~
另外还有两个异常，`queue.Empty,queue.Full`，当Queue是空的同时非阻塞的get()唤起时，会引发前者，同样，当队列满的时候又唤起put方法时，就会引发后者 
上述的Queue指的是所有三种类型的队列 
同时这三种队列都有相同的一套方法 
- qsize(),这个方法会返回队列的近似尺寸，但是大于零不保证get()不会阻塞，小于零也不保证put()不会阻塞。这你妹的有啥用呢？

- empty(),当队列是空的的时候，返回值为True，但是它和下面的full方法一样，都不能保证进行get或put方法时不会阻塞  

- full()

- put(item,block=True,timeout=None)，把item放进队列，

### 再叙Thread

关于一个线程，一般使用两个方式，要么直接实例化一个类，把要执行的函数以参数的形式传递进去，要么新建一个类，继承threading.Thread，对于一个新建的类，我们需要重写的方法只有两个，一个是__init__,另一个就是run，对于一个线程而言，当我们调用它的start()方法后，它就会开始以某些方式调用自己的run方法，所以本质上，run就是一个线程的主函数，当run执行完毕之后，线程就终结了。另外必须要注意的就是，如果将线程设置为守护线程，则当主线程结束时，不必等待该线程也结束，就会直接结束整个程序，还有一个join方法，如果线程A中调用了线程B的join方法，那么如果B不结束，线程A就会一直阻塞，无法结束。 
呃，join方法还是需要详细解释，如果线程A的程序中某一段写了B.join()，那么A会被阻塞在这个位置，直至B执行结束，A才会继续向下执行。 
所以可以说，对于最最基本的多线程的使用，为了让线程不在主线程结束的时候也结束，那么既可以将线程设置为非守护线程，也可以调用一下join方法。 



### ThreadPool

我写了一个线程池，时间已经蛮久了，我没有写任何文档和注释，所以现在我自己看起来也很难懂，这里只是大概写一些用法。

首先我们要从模块中导出两个类：ThreadPool和Work

前者就是线程池，后者是用来包装工作的

首先呢，我们需要实例化ThreadPool，传入一个参数，就是线程池的尺寸，例如50

然后我们要调用线程池的put_work方法，把任务放进去，每个任务就是一个函数，但是需要使用Work进行包装，大概是这个样子的：

`m.put_work(Work(target=scanner,args=(i,)))`

其中的scanner就是任务的函数名，参数的话就是用上面的方法传入，但是如果只有一个参数的话必须加一个逗号。

接下来依次调用wait和stop方法就ok了，大概像下面：

~~~python
m = ThreadPool(50)
lock = Lock()
for i in range(1,1024) :
  m.put_work(Work(target=scanner,args=(i,)))
m.wait()
m.stop()
~~~

所以说任务一般是开始前就添加了的，基本的使用就是这样的，也许还有更多的用法，但是我真的已经忘记了。