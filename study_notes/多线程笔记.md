## 多线程
> -- by stan

### threading
推荐使用threading模块 
将一个线程设置为守护线程意味着这个线程是不重要的，整个python在所有的非守护线程推出之后就会退出。 
`threading.Thread(group=None,target=None,name=None,args=(),kwargs={},verbose=None,daemon=None)`

这是一个Thread类，这就是一个线程类 

属性：name,ident,daemon
方法：
- start(),开始执行这个线程
- run(),定义线程功能的方法
- join(timeout=None),直至线程终止前一直挂起，除非给出的时间到达

对象实例化的时候传入的target是目标函数，args是函数的参数，返回值是一个线程实例，线程并不会立即开始执行，直至调用start()方法，

如果必须要等待线程完成，则需要调用join()方法 

### 锁
threading模块提供了锁对象，Lock 
~~~python
lock = Lock()
lock.acquire()
lock.release()
~~~
锁对象有acquire方法和release方法，前者是锁定，后者是释放锁 

### 信号量

threading模块提供了两种信号量类Semaphore和BoundedSemaphore。

BoundedSemaphore实例化的时候要提供一个最大值，其资源总数永远不会超过最大值，信号量同样使用release方法增加一个资源，acquire方法获取一个资源

记得必须使用锁来保证对于信号量的互斥操作

### queue对象

queue适用于多生产者，多消费者的任务，当多线程编程中信息必须安全的更改时，queue很有用。
queue提供了三种类型的队列，FIFO,LIFO，Priority queue。很明显的吧，分别是先进先出，栈和优先级队列。
这三者分别是三个类

~~~python
queue.Queue(maxsize=0)           FIFO
queue.LifoQueue(maxsize=0)       LIFO
queue.PriorityQueue(maxsize=0)   priority queue  
~~~
另外还有两个异常，`queue.Empty,queue.Full`，当Queue是空的同时非阻塞的get()唤起时，会引发前者，同样，当队列满的时候又唤起put方法时，就会引发后者 
上述的Queue指的是所有三种类型的队列 
同时这三种队列都有相同的一套方法 
- qsize(),这个方法会返回队列的近似尺寸，但是大于零不保证get()不会阻塞，小于零也不保证put()不会阻塞。这你妹的有啥用呢？

- empty(),当队列是空的的时候，返回值为True，但是它和下面的full方法一样，都不能保证进行get或put方法时不会阻塞  

- full()

- put(item,block=True,timeout=None)，把item放进队列，

### 再叙Thread

关于一个线程，一般使用两个方式，要么直接实例化一个类，把要执行的函数以参数的形式传递进去，要么新建一个类，继承threading.Thread，对于一个新建的类，我们需要重写的方法只有两个，一个是__init__,另一个就是run，对于一个线程而言，当我们调用它的start()方法后，它就会开始以某些方式调用自己的run方法，所以本质上，run就是一个线程的主函数，当run执行完毕之后，线程就终结了。另外必须要注意的就是，如果将线程设置为守护线程，则当主线程结束时，不必等待该线程也结束，就会直接结束整个程序，还有一个join方法，如果线程A中调用了线程B的join方法，那么如果B不结束，线程A就会一直阻塞，无法结束。 
呃，join方法还是需要详细解释，如果线程A的程序中某一段写了B.join()，那么A会被阻塞在这个位置，直至B执行结束，A才会继续向下执行。 
所以可以说，对于最最基本的多线程的使用，为了让线程不在主线程结束的时候也结束，那么既可以将线程设置为非守护线程，也可以调用一下join方法。 



经过试验之后，我再重申一次，如果一个子线程是守护线程，那么主线程结束时，无论子线程结束与否，子线程会随之结束，但是子线程默认情况下都是非守护线程，换句话说，默认情况下即便不做任何设置，主线程结束后，各子线程依旧会完成自己的工作，然后结束。也就是说，一般情况下，我们只是想让各个子线程完成自己的工作，那么不需要多些什么代码，只要保证每个线程都调用了一次start方法即可，只有当我们希望每个子线程都结束后主线程可以完成一些输出的时候我们才需要调用join方法，否则，join完全没有必要。



### ThreadPool

我写了一个线程池，时间已经蛮久了，我没有写任何文档和注释，所以现在我自己看起来也很难懂，这里只是大概写一些用法。

首先我们要从模块中导出两个类：ThreadPool和Work

前者就是线程池，后者是用来包装工作的

首先呢，我们需要实例化ThreadPool，传入一个参数，就是线程池的尺寸，例如50

然后我们要调用线程池的put_work方法，把任务放进去，每个任务就是一个函数，但是需要使用Work进行包装，大概是这个样子的：

`m.put_work(Work(target=scanner,args=(i,)))`

其中的scanner就是任务的函数名，参数的话就是用上面的方法传入，但是如果只有一个参数的话必须加一个逗号。

接下来依次调用wait和stop方法就ok了，大概像下面：

~~~python
m = ThreadPool(50)
lock = Lock()
for i in range(1,1024) :
  m.put_work(Work(target=scanner,args=(i,)))
m.wait()
m.stop()
~~~

所以说任务一般是开始前就添加了的，基本的使用就是这样的，也许还有更多的用法，但是我真的已经忘记了。



下面我来详细解释一下线程池的工作流程，与使用时的注意事项。

线程池模块主要包含了四个类：WorkDone，Work，WorkThread，ThreadPool

-   WorkDone，是一个异常类，继承了Exception，用于指示工作已经全部完成
-   Work，用于包装工作函数，主要提供了id，并且提供了输出字符串，用于定制print
-   WorkThread，继承自threading.Thread，每一个工作线程都是一个实例
-   ThreadPool，线程池的协调控制者



对于每一个工作函数，我们做的包装其实并不多，只是提供了id，同时把真正的工作函数定义为属性`work_fun`

同时把参数也使用属性存储起来

对于每一个工作线程，初始化的时候所做的工作依次分别是，定义自己的工作队列，将从此队列中获取任务；定义结果队列，将把每一项任务的结果以(Work类,返回值)这样的二元组，存入结果队列；定义请求任务时的timeout；把回收信号定义为线程里面的Event类；然后开始运行。

线程在运行的时候会死循环做以下任务：检查是否收到被回收信号，是的话跳出循环，结束运行，否的话进行下一步；向任务队列请求一个任务，如果得到队列为空的异常则跳回开头，直接进行下一轮循环，否的话执行下一步；再次检查自己是否被要求回收，是的话，放回任务，否的话继续下一步；执行任务，将结果放入结果队列，如发生异常，直接pass，此时的任务会无法正常完成，但是不会影响整体工作。

当工作线程被初始化之后，就开始了这样死循环式的请求--工作的循环。唯一的结束方式就是收到回收信号。

默认情况下，为了防止主线程出现任何问题，所以每个工作线程都被设置为了守护线程。



线程池类负责调度处理。

第一步会创建人物和结果队列，然后设置timeout，因为后续管理的需要，还必须创建一个工作线程的列表，被回收线程列表，任务的字典；

然后根据要求创建指定数目的工作线程，加入到工作线程列表中。

到此初始化工作完成，所有员工已经开始工作，但是事实上任务并不存在。

之后我们应该向任务队列中放入任务，直接调用`put_work`方法即可，这里，线程池会完成两个工作：将任务加入任务队列，并以`id:Work类`的形式在任务字典里面注册

只要我们还需要加入任务，我们就不应该调用下一个方法。

当所有任务已经加入完毕，不会再添加，只是在等待所有任务结束的时候，我们应该调用wait()方法，这个方法会做一件事，死循环获取任务结果，直至收到任务完成的异常，然后跳出循环，告诉用户所有任务已经完成。

最后，还要清理现场，回收所有线程，这一步只需调用stop()方法即可。

详细描述一下wait()里面的获取任务结果和stop()方法。

获取任务结果这一步会不停的检查任务字典是否为空，是的话代表已经没有任务了，触发WorkDone异常即可；否则的话，则需要从结果队列中获取一个结果，然后从任务字典中删除这个结果所对应的任务。

stop方法，则是循环把所有在工作线程列表中的员工的回收信号设置为True，默认情况下会使用join，也就是阻塞主线程，等待所有工作线程销毁，为防止意外，还会再调用一次`join_dismiss_thread`方法，再阻塞主线程，直至完成工作线程销毁。



所以综合以上的描述，我们的使用步骤是：

1.  创建一个线程池实例，传入线程数
2.  放入任务，调用`put_work`方法，注意要包装工作函数
3.  任务加入结束，调用`wait`方法，等待任务完成
4.  调用`stop`方法，清理现场，销毁所有工作线程

所以，明显这里没有提供返回值的接口，但是也很简单，我们只需要改造一下`ThreadPool`类，把从结果队列里面拿到的结果以我们想要的形式存储到一个我们想要的属性里面即可。



