## C和C++代码组织与编译

### 目的

我希望可以掌握尽可能靠近底层的本质，所以，最近我在尝试脱离IDE学习c和c++，并尝试一些更加复杂的东西，例如手工编译opengl等，下面是一些进展和经验。

我并不能保证下面写的都很正确，很有可能某些术语或者是细节描述都不太准确，但是整体的脉络和架构应该是没有问题的，对于我这种完全不了解这些东西的人来说，还是很有参考意义的。



### 编译与编译器

C和C++都是编译型语言，源代码经过编译过程会生成特定架构下的可执行文件，之后的运行不需要在经过任何特殊的操作，只要是同一平台下都可以直接执行上述的可执行文件，正是因为这一点我才会选择使用这两个语言，它赋予了我分发的能力。

编译的大概了解的吧，粗略的来讲，可以认为分为编译和连接两个过程(准确地描述似乎是四个过程，不过我认为前三个过程并非有控制的必要，也就不必区分的太过仔细)。

编译过程将源代码编译为目标文件或称对象文件(object file)，生成的文件一般是`.o或者.obj`文件，这个过程只涉及本文件自身的处理，换句话说即便文件通过头文件引用了其他库，这一步也不会处理这些库。

链接过程将会分析文件的库依赖关系，然后将必要的库连接到代码上，然后生成可执行文件，windows平台下是exe文件，Unix平台下是out文件。

我们可以通过编译器来控制上述过程，也就是说可以只编译，也可以控制连接。

所以接下来，编译器就很重要了，编译器还是挺多的，关键在于不要混用不同的编译器，例如库用VC编译，然后代码用GNU编译器编译，这种情况下往往会出问题。

编译器有很多，但是这里我不会说太多，因为目的并不在于研究编译器，只要这些编译器足够常见，足够用就好了。所以这里要说的主要是Visual Studio用的微软的编译器和GNU的编译器。

Visual studio是微软的IDE，很多情况下我们不得不使用他的编译器进行编译，这时基本上我们就需要安装Visual Studio，他的编译器似乎叫作Visual C++，我很少使用，因为安装实在太麻烦了，不够轻量级，我不太喜欢完全被定制。

所以，我主要使用的编译器就是GNU的编译器，在windows下，要使用GNU的编译器，我们需要安装mingw，这个工具相当于GNU编译器的一个打包，只需要下载，安装即可。

安装的过程中，我们需要注意选择32位还是64位，注意要保持一致性。然后我们需要打开bin目录，在这个目录下我们可以发现一系列的exe文件，我们知道每一个windows的cmd或者power shell下的命令都对应一个exe文件，所以说这里是就是mingw为我们提供的命令。我们需要将这个bin文件夹加入path中，这样我们就可以在任意目录下调用这些命令了。

然后，事实上，我们的目的就是编译c和C++，所以考虑到这些其实我们经常使用的就是这个目录下的gcc，g++以及ar,还有make，注意要将这个目录下的`mingw32-make.exe`更名为`make.exe`这样才能直接使用make命令

这里的gcc是用来编译c的c编译器，g++是c++的编译器，ar用于生成链接库，make用于使用makefile的复杂代码编译。



现在再重新聊一下编译器，其实有人说有一个叫clang的编译器不错，但是，我还是选择GNU吧。在Linux平台，我已经证明了64位平台上的64位GNU编译器可以完成32位的编译，以及运行，但是在目前的WSL上面是不行的，也许等到19年7月发布WSL2会有所改变。是的，经测试在WSL2里面是可以运行的。

说回win平台，我选择mingw，现在win平台的mingw的64位版本名字叫做mingw-w64，下载的时候，默认的下载方式获取到的是一个下载器。然后选择版本什么的，下载器在从网上下载选择的版本，并安装，但是我已经失败了很多次了。如果安装失败，解决的方法是直接去`sourceforge.net`下载需要的版本，版本的选择可以参考[这个页面](https://www.cnblogs.com/ggg-327931457/p/9694516.html)，说的很详细。

简而言之，需要选择的首先是版本，肯定选最新的

然后是系统架构，选64位，然后选操作系统接口协议，可选posix或者win32，按道理来说，似乎如果开发的是win程序，应该选win32，无论32位还是64位，但事实证明我选择posix也没有任何问题。

异常处理模型，如果选择了64位系统，可用的异常处理模型有seh和sjlj，前者性能好，问题是不能再使用`-m32`实现32位编译，所以我选后者

如果选择了32位模型，可选的是`dwarf和sjlj`

再说回`sourceforge`，`mingw-w64`的地址是`https://sourceforge.net/projects/mingw-w64/files/`，我们应该选择`win64的toolchains`文件夹，然后进入`personal builds`里面的`mingw-builds`，接下来就是选版本，接口协议，异常处理模型。

之后就可以通过`gcc -m32`来实现32位的编译。

### 代码组织

我们知道一种合理化的代码组织形式是将不同的功能分割为不同的模块，也即多文件的代码组织形式。

在python中，我们会使用import来实现多文件的代码组织形式，而文件的查找一般就是通过import指定文件名字，当前工作目录和path制定的路径进行查找，所以说，这是一个相当清晰的流程和形式。

但是在C/C++中，事情似乎会变得更加复杂。在这里，我们通过头文件来实现多文件的组织。例如：一个类的定义源文件stan.cpp，声明文件也即头文件stan.h，使用的文件main.cpp。我们会通过在main.cpp中包含stan.h实现多文件的组织。这种情况下实际上stan.cpp就是一个库文件。当然这只是一个简单的情况，复杂的情况下，库当中会包含多个文件，并且之间也存在着相互包含的关系。

所以我们要考虑的问题就是如何使用库，这里的stan.cpp实际上就是我们的库的源代码。而库的使用也有两种途径，在简单的情况下，就如我们现在的情况，我们可以直接在编译中使用；但是当库变得十分复杂，牵扯到众多文件的时候，我们会选择使用第二种方式：通过二进制文件在连接环节使用库，即将库编译为二进制文件，然后在链接的时候引用这个二进制文件。

第一种方式的实现十分简单，针对我们的这个例子，可以直接使用如下命令，编译即可：

`g++ main.cpp stan.cpp`

对于第二种方式，问题还会变得更加复杂。

第二种方式前面已经说了是在链接环节引用库文件，这意味着我们必须首先将库文件的源码编译为二进制文件，于是这个过程会让库变成依赖于特定架构的。然后一种连接方式是`连接器将从库文件取得所需的代码，复制到生成的可执行文件中，这种库称为静态（链接）库，其特点是可执行文件中包含了库代码的一份完整拷贝，缺点是被多次使用就会多份冗余拷贝。还有一种库，就是程序在开始运行后调用库函数时才被载入，这种库独立于现有的程序，其本身不可执行，但包含着程序需要调用的一些函数，这种库称为动态（链接）库`

在windows平台，静态链接库是`.lib`文件，动态链接库是`.dll`文件，linux平台，动态链接库是`.so`文件，静态链接库是`.a`文件

关于库文件的这两种使用方式，各有优缺点，第一种方式是清晰，并且不需要经过额外的编译步骤，只需要有库文件的源码即可，但是当库文件十分复杂的情况下，这种方式就会变得很难使用。第二种方式的优点是代码具有隐蔽性，所谓接口可见，代码不可见，相当于帮我们完成了完美的包装，然后给出了完整的接口，我们不需要考虑库内部的代码组织和调用细节，缺点是必须经过额外的编译，并且因为编译成了二进制形式，他会变成依赖于特定平台的。



### 编译控制与库的使用

首先我们再回顾一下代码的组织，前面说了，类的实现一般会写成stan.cpp，而类的声明写在头文件stan.h中，在main.cpp中，我们会通过包含stan.h来实现包含库，那么要注意的是头文件的写法。

常见的头文件的写法有这么几种：

~~~c++
#include<iostream>
#include"stan.h"
#include<GLFW/glfw3.h>
~~~

上面的`<>`和`""`两种形式的区别在于，前者一般是标准库的写法，后者一般是我们自己的头文件的写法，对于两者在处理上的唯一区别就是搜索路径不同，前者会直接搜索标准目录，后者则会首先搜索当前目录，然后搜索标准目录。对于IDE来说，应该还是挺重要的，对于手动编译而言，我们完全可以通过参数增加额外的头文件搜索目录，所以二者就相当于没有区别了。

对于第三种形式，它实际上对应的就是文件夹结构，它的意义代表包含GLFW目录下的glfw3.h头文件



于是，接下来要考虑的问题就是实际操作，如何只编译不连接，如何生成静态链接库，如何生成动态链接库，如何使用链接库

前面说不同平台下各种链接库的后缀，但是实际上应该这样说微软编译器得到的静态链接库和动态链接库分别是`.lib`和`.dll`文件，GNU编译器(GCC G++)得到的链接库分别是`.a和.so`文件，他们并不代表你只能在windows或者Uniux操作系统下才能使用，即便在windows下，只要你全程都使用GNU编译器，你照样可以使用`.a,.so`链接库

前面已经说了，我主要使用mingw，所以，这里我着重说明`.a和.so`链接库的使用

首先要说明的是，gcc和g++常见的参数形式都是一致的，所以下面的参数我说的都是g++，但是对于c文件的gcc同样可以这样使用

`g++ -c stan.cpp`，这里的`-c`参数的意义是只编译不连接，将会得到`.o`文件

静态链接库也必须首先将源文件编译为目标文件，然后再使用ar命令得到链接库

例如，我们有stan.h，stan_add.cpp,stan_sub.cpp,main.cpp几个文件，stan.h是头文件，后两者是实现文件，mian.cpp是主文件，目标是将两个实现文件分别编译为动态链接库和静态链接库，然后尝试使用

在GNU的整个体系中静态链接库的命名是`libstan.a`，`lib`是前缀，stan是库名字，使用ar命令将一或多个目标文件生成为一个静态链接库，所以整个命令过程是：

~~~
g++ -c stan_add.cpp
g++ -c stan_sub.cpp
ar cqs libstan.a stan_add.o stan_sub.o
g++ -o main main.cpp -L. -lstan
~~~

要解释的就是最后一条命令， `-o mian`代表我们指定了输出的可执行文件的名字为main, 后面紧跟着的就是主文件的源代码`main.cpp`， 然后`-L.`指定将`.`加入库文件的搜索目录，是的中间没有空格，很诡异， 然后`-lstan`代表了要链接进去的库是`stan`，这样编译器会自动将名字为`libstan.a`的静态链接库链接进去

然后ar的那个命令结构是很明显的，关键是`cqs`这个参数代表什么意思，这个其实我没有太深究，[这里](https://blog.csdn.net/xuhongning/article/details/6365200)给出了详细解释，但是看不太懂 

接下来是动态链接库，动态链接库实际上是被称为`Shared libraries`，然后分解一下，它的生成也是要首先生成目标文件，然后将目标文件生成链接库，命令如下：

~~~
g++ -fPIC -c stan_add.cpp
g++ -fPIC -c stan_sub.cpp
g++ -shared -o libstan.so stan_add.o stan_sub.o
g++ mian.cpp -L. -lstan
~~~

这是分解的用法，实际上还可以使用组合的命令：

~~~
g++ -fPIC -shared -o libstan.so stan_add.cpp stan_sub.cpp
g++ main.cpp -L. -lstan
~~~

两种方式均可正常生成动态链接库，但是你可以尝试一下，只要是在windows下，即便你是用mingw编译器进行编译，你会发现最后一条命令依旧不能使用，这是因为.so的动态链接库是Linux下的，windows下面无法使用，所以，即便使用GNU编译器，在windows下，也就是到静态链接库为止了，真的想使用静态链接库，只能用`.dll`，那么，我想也许编译器都要同时更换

即便不能用，我接下来还是要说一下动态链接库的进一步知识，动态链接库为什么叫动态链接库？

在使用静态链接库的时候，当我们完成最后的编译之后，我们可以直接将libstan.a删掉，运行main.exe依旧是正常的，这说明库已经被整合到可执行文件当中了，而对于动态链接库，前面也说了是在运行时载入的，这意味着，一旦你移除了.dll库或者.so库，可执行文件就不能运行了，这就是动态链接的意义

各处都提到了一个我无法验证的问题，就是说对与动态链接库当编译完成后，执行时依旧会报出找不到动态链接库的错误，这是因为系统不知道去哪寻找动态链接库，虽然在编译中我们写过`-L.`参数，但这只是指定了编译时寻找库的目录，并不代表运行时。所以需要再执行一条命令：

`export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:.`它会把当前目录加入动态链接库寻找目录

这里，我使用了两个优秀的参考网页，[一号](https://stackoverflow.com/questions/10358745/how-to-use-libraries)，[二号](https://blog.csdn.net/surgewong/article/details/39236707)，感谢他们，给我提供了巨大的帮助



再加一个惊喜，前面说了winsows下我们不能使用.so动态链接库，只能使用.dll，那么是不是意味着我们就要抛弃动态链接库，或者放弃GNU编译器吗？GCC或者G++给我们的惊喜是他也可以编译产生.dll动态链接库，并且使用：

~~~
g++ -shared -o stan.dll stan_add.cpp stan_sub.cpp
g++ main.cpp -L. -lstan
~~~

然后就可以使用了，这似乎是简单情形下，只要包含了动态链接库内对应文件的头文件，就可以使用库内的定义。但是似乎还有其他[复杂的用法](https://blog.csdn.net/lhq9220/article/details/6612499)，我现在也用不上那么复杂的，这样吧先，也感谢这篇博客的作者。



最后，[这一篇博客](https://www.cnblogs.com/laojie4321/archive/2012/03/30/2425015.html)也为我提供了最初的帮助，有些东西似乎很深入，但是暂时我没有继续看



### 以GLFW为例的实战

到这里为止，我们就掌握了简单的库的用法，接下来就以glfw为例，说一下更进一步的操作

到此时此刻为止，我还没有解决自行使用cmake将glfw编译为.a静态链接库的问题，所以暂时我使用的是预编译的libglfw3.a

这里先解释一下概念，glfw负责为opengl提供窗口生成和管理功能，这是一个当前比glut有前途的库，并且也是一个复杂的c库，然后同时我们要使用glad，glad是一个桥梁，或者说是小工具，因为glfw直接和windows交互实际还要做很多重复性的设置等等，很麻烦，glad就是负责替我们完成这个任务的，这里说的可能不准确，但大概是这个意思。glad之前还有一个glew，但是glad比他更加优秀，所以取代了。glad相对简单，只有一个glad.h文件和glad.c文件

然后我们只需要取出glfw3.h这个头文件，这样，有了libglfw3.a和glfw3.h实际上我们就有了glfw这个库，然后我们极可能还需要glad这个库，去官网下载，按照[这里](https://learnopengl-cn.github.io/01%20Getting%20started/02%20Creating%20a%20window/)的配置说明进行配置，然后我们会得到glad.c和glad.h两个文件，他们就构成了glad库，然后根据所使用的测试样例，很可能还会依赖`linmath.h`和`KHR/khrplatform.h`两个头文件，这样再加上一个测试用的主文件，例如glfw的example中的`boing.c`我们便具有了全部的库和文件

明显，这里glad也是一个库，我稍微做了一个尝试，不编译，直接按照原本那种一气呵成的库使用方法似乎是不可以的，可能是因为我们使用了链接库吧，所以，总之，我们要先编译一下glad，编译为目标文件：

`gcc -I. -c glad.c`

这里，首先我们必须按照合适的方式放置头文件，然后`-I.`参数将`.`加入头文件搜索目录，这个参数很重要，其后也会多次使用，然后我们就可以执行最后的编译boing.c例子了：

`gcc -I. -L. -o boing boing.c -lglfw3 -lopengl32 -lglu32 -lgdi32 glad.o`

这个命令里面的绝大多数参数我们已经十分熟悉了，只有`-lopengl32 -lglu32 -lgdi32`不熟悉，根据预先的知识，我们知道这是在使用三个链接库，分别是opengl32, glu32, gdi32，为什么要加上这三个库？因为这是glfw官网说要用的，这三个库在哪？这三个库是三个动态链接库：`opengl32.dll,glu32.dll,gdi32.dll`它们在windows的系统目录中，编译器会自动寻找，我们不需要担心

然后就可以看到boing.exe这个可执行文件了，运行即可。



### 编译与路径

以我常用的`gcc`和`g++`编译工具来说，在编译的过程中路径还是挺重要的，采用一种划分方式，可以认为重要的路径有三种，输出文件的存储路径，源文件的位置路径，依赖文件的位置路径

首先据经验编译器会去系统目录寻找必要的依赖，这里的系统目录具体是哪些我并不十分清楚，但是可以肯定的是对于标准库，以及一些由系统提供的依赖文件编译器是会自动找到他们的位置的，除此之外就是默认情况下的当前目录

然后，上述两种命令还提供了两个用于指定添加搜索路径的参数`-I -L`分别是头文件目录，链接库目录

除此之外的我知道的唯一途径就是通过相对或者绝对路径来控制路径了。否则的话输出文件只会位于当前文件夹下，源文件也只会到本文件夹寻找。



### makefile

当编译工作变得更加复杂的时候，我们通过这种手动逐条输入命令就会显得很麻烦，此时我们需要makefile，实际上，上述过程我们也可以通过makefile来完成。

并不准备很详细的写makefile的笔记，因为陈皓的跟我一起写Makefile已经是一篇相当好的教程和笔记了，[这里是重制版的PDF](https://github.com/seisman/how-to-write-makefile)

所以下面只是记录一些对我有意义的要点。

#### 依赖文件

我并不确定我说的对不对，考虑一下就可以知道，理性上面我们的依赖文件的最大范围是命令中使用到的文件，再加上文件所使用的头文件。所以有了最大范围，问题是最小范围是多少，我认为是空，我们可以完全不写。可以这样做的原因我认为是依赖文件的作用只是一个判断语句的条件而已，据陈皓的博客说，makefile的核心就是：

`如果target不存在，或者依赖文件中任意文件比target要新，则执行下面的命令`

所以说，我认为依赖文件在一定程度上是可以任意写的。明白我的意思吧。举一个激进一点的例子，我们可以在某个文件的依赖文件里面写一个与之完全无关的txt文件的名字，然后实现，只要我一改动txt文件，就会促使目标重新编译一次的行为。

#### 处理范围

要搞清楚哪些属于makefile的规则处理范围，哪些不是，例如我们可以通过vpath设置文件的寻找路径，但是这个路径并不会应用到command中g++的寻找路径当中去。如果想要使用我们必须使用一些特殊的手段，例如自动化变量

[这里是一个参考](https://codereview.stackexchange.com/questions/78855/makefile-for-c-opengl-with-glfw-and-glad)



规则：

~~~makefile
target ... : prerequisites ...
	command
	....
	....
~~~

变量与引用：

~~~makefile
a = main.o kde.o xxx.o
$(a)
~~~





### C语言模块化编程

因为最近在写OS，要写不少的C，所以，我希望可以规范化我的C代码。



常量的定义，使用宏定义在头文件中。

[参考资料](https://www.icosaedro.it/c-modules.html)



#### static与extern

这两个关键词在C标准中叫做存储类限定符，因此他们先顶了如何存储分配内存，以及在连接中的行为。

我的参考资料是[这一篇博客](https://radek.io/2011/09/01/static-and-extern-keywords-in-c/)，感觉应该是比较靠谱的。按照博客里面的说法，我们应该这么理解：对于代码，应该分为两个部分进行考虑，一个部分叫做链接阶段，一个叫做存储类型。

链接部分定义了对象(函数和变量)在链接中的行为，也就是是否对其他文件可见。而存储部分定义了一个变量在生命周期中是如何存储的。

extern和static两个关键词会同时影响着两个阶段，所以容易产生困惑。

##### 链接

链接可以分为三种类型：external, internal，none

external意味着对象是整个程序都可见的，是跨模块的。这里程序指的是整个程序，整个程序可以有多个文件或者说模块组成。默认情况下定义在文件作用域或者说全局作用域的对象都默认是external，也就是说所有的全局变量和函数都是external。

这里我想，external并不意味着直接就可用，他只意味着是可用的，但是要使用还必须要让其他模块知道它们的存在，所以需要头文件，或者其他方式。

举个简单的例子

~~~c
// a.c
int func()
{
    return 4;
}
~~~

~~~c
//main.c
int main()
{
    int a = func();
    
    return 0;
}
~~~

使用`gcc main.c a.c`一同编译两个文件，肯定是无法通过的，虽然func是external的，但是main并不知道它，所以，我们需要一个头文件为这个函数做一个声明，例如：

~~~h
// a.h
#ifndef _A_H
#define _A_H

int func();

#endif
~~~

然后在两份源码中包含这个头文件，程序自然就能正常运行了。

但是其实还有其他办法，如上所述，其实为什么main不能使用func，就是因为它少了一个func的声明，所以可以完全不要头文件，只需要在main.c中给出一个这个函数的声明就行了，例如：

~~~c
//main.c

extern int func();

int main()
{
    int a = func();
    
    return 0;
}
~~~

其实，这里面的声明一定需要extern吗？并不是`int func();`也行，那么为什么要写`extern`，我的理解是一种规范的手段，如果不带`extern`我们习惯性会认为这个定义也是在这个文件内，而`extern`的意思是这只是一个声明，定义在别的文件。

这也是为什么cJSON这个项目的头文件中对于源码的函数的声明都带上了extern，我觉得这大概确实是一种更加规范的做法，应该学习一下。



对于函数来说，定义和声明是有显著区别的，声明是没有函数体的。

但是对于变量而言，区别就没有那么明显了。好吧说实话，这里我被博客里面的例子搞得有点混乱了。

在全局作用域里面：

~~~c
//main.c
// Example 1

extern int a;
//  声明变量a， a的定义不在本文件

int b;
// 变量b的暂时定义

static int c;
// 变量c的暂时定义， c的链接是internal的

int b = 10;
// 变量b的定义

int main()
{
    return 0;
}
~~~

我们可以有这么几种写法。我其实真的不知道确切地解释是怎样的。

变量只能定义一次，但是可以声明多次。

对于变量必须区分全局作用域和局部作用域。按照前面的说法，全局里面的对象默认都会带一个`extern`，所以实际上在全局我们写`int a;`的时候，实际上是`extern int a;`

那么对于变量究竟什么是声明什么是定义？这么说吧：

~~~c
extern int a;
//声明
int a；
//定义
int a = 10;
//带初始化的定义
extern int a = 10;
//依旧是定义
~~~

那么回看前面的Example 1为什么可以先写`int b;`再写`int b=10;`，毕竟这两个都是定义，但是如前所述实际上在全局会被加上`extern`所以第一个就被变成了声明。所以example 1可以那样写，但是下面这样就不行了：

~~~c
int main()
{
    int b;
    int b=10;
    return 0;
}
~~~

因为这两个都是定义。

static还可以修饰变量和函数，在全局作用域static修饰变量和函数意味着它们是internal的，也就是作用在链接阶段。

如果static修饰局部作用域的变量，那么他的作用在存储部分的，意味着这个变量是静态的，也就是生命周期不是只在这个作用域，就是会被保留，而`static int a=10;`这一句初始化只会执行一次。

我觉得我现在是真的懂了，但是我说的非常啰嗦，还是去看一下那个博客吧。

#### 总结

总结一下，static和extern这两个修饰符都是为了处理作用范围，存储以及规范化而服务的。

不同文件也即一个程序的不同模块的全局作用域是共通的，也即默认都是external的，所以它们不能定义相同名字的函数和变量，但是一个模块想要使用另一个模块的对象也不是直接用就行，必须要经过一个声明，这个声明自然可以通过extern也可以通过头文件，所以规范化一点，实际上头文件里面函数的声明也会写一下extern。

那么static有什么用呢？两个用途，第一如果你不希望本文件的对象被其他文件使用，就定义为static，那么它们就被限定到了本文件，第二，如果你希望局部作用域的变量保持生命，那么可以修饰为static

所以，我现在制定一下我认为规范的做法如下：

一个模块中的对象，包括函数和变量，如果希望被其它模块使用，那么不需要任何修饰。如果不希望就修饰为static。

头文件应该作为模块之间共享对象的介质，头文件中不应该包含对象的定义，只能包含声明，因为定义不在本文件，那么自然都应该带上extern。

还是那句话extern只是一个声明，我们希望它代表此处是一个声明，定义不在本文件。

唉，我觉得我还是没说清楚。表达能力太差。



额外说一下，对于枚举应该是只有声明没有定义。所以：

~~~c
enum Colors
{
	Black=0, White, Red, Green, Blue, Gray, Cyan, Yellow, Magenta, Brown
};
~~~

是声明，而不是定义。



### 规范化

模块化编程与规范化设计，C语言还是比较注意规范化和访问控制的，在接下来的编程中，我应该按照上面的extern和static控制模块化与规范。

另外就是要注意使用const来规范化。

这些都是学自cJSON